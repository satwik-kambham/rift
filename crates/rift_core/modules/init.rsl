# Dashboard

dashboardId = -1
dashboardText = "
Welcome to rift!

Basic Keybinds:

esc - Quit Insert Mode
i - Enter Insert Mode
space q - Quit
space f - Fuzzy File Picker (with fd & fzf)
space F - File Explorer
space b - Switch Buffer
"

fn createDashboardBuffer() {
    if dashboardId == -1 {
        bufferId = createSpecialBuffer("Dashboard")
        setBufferContent(bufferId, dashboardText)
        setActiveBuffer(bufferId)
    }
}

createDashboardBuffer()

#################

# Agentic Chat

fn toolDeclarations() {
    return
"[
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"run_shell_command\",
            \"description\": \"Run a shell command and return the output\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"command\": {\"type\": \"string\"}
                },
                \"required\": [\"command\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"find_file\",
            \"description\": \"Returns paths matching regex pattern by searching recursively in the workspace folder, returning absolute paths. Does not accept glob patterns.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"search_workspace\",
            \"description\": \"Grep search in the current workspace for matching patterns\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"read_file\",
            \"description\": \"Get the content of a file with line numbers\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"path\": {\"type\": \"string\"}
                },
                \"required\": [\"path\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"write_file\",
            \"description\": \"Writes content to a specified file replacing the existing content.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"content\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"content\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"replace\",
            \"description\": \"Replaces text within a file. Can replace single or multiple occurrences.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"old_string\": {\"type\": \"string\"},
                    \"new_string\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"old_string\", \"new_string\"]
            }
        }
    }
]"
}

fn agentRunShellCommand(command) {
    outputs = runShellCommand(command, getWorkspaceDir())
    return "STDOUT:\n" + tableGet(outputs, "stdout") + "\nSTDERR:\n" + tableGet(outputs, "stderr")
}

fn agentFindFile(pattern) {
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

fn agentSearchWorkspace(pattern) {
    results = runShellCommand("rg " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

llmChatId = -1
chatInput = ""
chatHistory = createArray()
pendingToolCalls = createArray()

fn renderLLMChat() {
    content = ""
    i = 0
    loop {
        if i >= arrayLen(chatHistory) { break }
        message = arrayGet(chatHistory, i)
        content = content + "\n------\n" + tableGet(message, "role") + ":\n" + tableGet(message, "content")
        toolCalls = tableGet(message, "tool_calls")
        if toolCalls != null {
            content = content + "\n\n" + toJson(toolCalls)
        }
        content = content + "\n------\n"
        i = i + 1
    }
    if arrayLen(pendingToolCalls) != 0 {
        i = 0
        loop {
            if i >= arrayLen(pendingToolCalls) { break }
            toolCall = arrayGet(pendingToolCalls, i)
            content = content + "\n" + toJson(toolCall) + "\n"
            i = i + 1
        }
    }
    content = content + "\n------\n" + chatInput + "\n------\n"
    setBufferContent(llmChatId, content)
}

fn requestChatCompletion() {
    apiKey = getEnvVar("OPENROUTER_KEY")
    
    request = createTable()
    tableSet(request, "model", "mistralai/devstral-small")
    tableSet(request, "messages", chatHistory)
    tableSet(request, "tools", fromJson(toolDeclarations()))
    tableSet(request, "stream", false)
    tableSet(request, "temperature", 0.3)
    tableSet(request, "seed", 42)

    body = toJson(request)
    response = postRequestWithBearerToken("https://openrouter.ai/api/v1/chat/completions", body, apiKey)
    response = fromJson(response)
    message = tableGet(arrayGet(tableGet(response, "choices"), 0), "message")
    toolCalls = tableGet(message, "tool_calls")
    
    if toolCalls != null {
        i = arrayLen(toolCalls)
        loop {
            if i <= 0 { break }
            toolCall = arrayGet(toolCalls, i - 1)
            
            arrayPushBack(pendingToolCalls, toolCall)
            
            toolName = tableGet(tableGet(toolCall, "function"), "name")
            toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
            toolCallId = tableGet(toolCall, "id")
            
            i = i - 1
        }
    }
    
    arrayPushBack(chatHistory, message)

    renderLLMChat()
}

fn getToolCallResult(allowed) {
    toolCall = arrayPopBack(pendingToolCalls)
    
    toolName = tableGet(tableGet(toolCall, "function"), "name")
    toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
    toolCallId = tableGet(toolCall, "id")
    
    result = "Tool call request denied by user. Await further instructions."
    
    if allowed {
        if toolName == "run_shell_command" {
            result = agentRunShellCommand(tableGet(toolArgs, "command"))
        }
        if toolName == "find_file" {
            result = agentFindFile(tableGet(toolArgs, "pattern"))
        }
        if toolName == "search_workspace" {
            result = agentSearchWorkspace(tableGet(toolArgs, "pattern"))
        }
        if toolName == "read_file" {
            result = agentReadFile(getWorkspaceDir(), tableGet(toolArgs, "path"))
        }
        if toolName == "write_file" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "content"))
        }
        if toolName == "replace" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "old_string"), tableGet(toolArgs, "new_string"))
        }
    }
    
    message = createTable()
    tableSet(message, "role", "tool")
    tableSet(message, "content", result)
    tableSet(message, "name", toolName)
    tableSet(message, "tool_call_id", toolCallId)
    arrayPushBack(chatHistory, message)
    
    renderLLMChat()

    if arrayLen(pendingToolCalls) == 0 {
        requestChatCompletion()
    }
}

fn allowToolCall() { getToolCallResult(true) }
fn denyToolCall() { getToolCallResult(false) }

fn sendMessage() {
    if arrayLen(pendingToolCalls) == 0 {
        message = createTable()
        tableSet(message, "role", "user")
        tableSet(message, "content", chatInput)
        arrayPushBack(chatHistory, message)
        
        renderLLMChat()
    
        requestChatCompletion()
    }
}

fn llmChatInputUpdated() {
    chatInput = getBufferInput(llmChatId)
    renderLLMChat()
}

fn llmChatAddSpace() {
    chatInput = getBufferInput(llmChatId)
    chatInput = chatInput + " "
    setBufferInput(llmChatId, chatInput)
    renderLLMChat()
}

fn llmChatClearInput() {
    chatInput = ""
    setBufferInput(llmChatId, chatInput)
}

fn createLLMChat() {
    if llmChatId == -1 {
        bufferId = createSpecialBuffer("LLM Chat")
        llmChatId = bufferId
        registerBufferKeybind(bufferId, "nor enter", sendMessage)
        registerBufferKeybind(bufferId, "ins space", llmChatAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", llmChatClearInput)
        registerBufferKeybind(bufferId, "nor y", allowToolCall)
        registerBufferKeybind(bufferId, "nor n", denyToolCall)
        registerBufferInputHook(bufferId, llmChatInputUpdated)
        renderLLMChat()
    }
    setActiveBuffer(llmChatId)
}

registerGlobalKeybind("nor space c", createLLMChat)

############

# Fuzzy Find File

fuzzyFileFinderId = -1
fuzzyFileFinderInput = ""
fuzzyFileFinderResults = createArray()
fuzzySelectedEntry = 0
fuzzyFileFinderPreviousBufferId = -1

fn renderFuzzyFileFinder() {
    content = "\n------\n" + fuzzyFileFinderInput + "\n------\n"
    i = 0
    loop {
        if i >= arrayLen(fuzzyFileFinderResults) { break }
        result = arrayGet(fuzzyFileFinderResults, i)
        if fuzzySelectedEntry == i {
            content = content + "\n > " + result            
        } if fuzzySelectedEntry != i {
            content = content + "\n   " + result 
        }
        i = i + 1
    }
    setBufferContent(fuzzyFileFinderId, content)
}

fn fuzzyFileFinderWorkspaceEntries() {
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path", getWorkspaceDir())
    fuzzyFileFinderResults = stringSplitLines(tableGet(results, "stdout"))
    fuzzySelectedEntry = 0
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderInputUpdated() {
    fuzzyFileFinderInput = getBufferInput(fuzzyFileFinderId)
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path | fzf -f \"" + fuzzyFileFinderInput + "\"", getWorkspaceDir())
    fuzzyFileFinderResults = stringSplitLines(tableGet(results, "stdout"))
    fuzzySelectedEntry = 0
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderAddSpace() {
    fuzzyFileFinderInput = getBufferInput(fuzzyFileFinderId)
    fuzzyFileFinderInput = fuzzyFileFinderInput + " "
    setBufferInput(fuzzyFileFinderId, fuzzyFileFinderInput)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderClearInput() {
    fuzzyFileFinderInput = ""
    setBufferInput(fuzzyFileFinderId, fuzzyFileFinderInput)
}

fn fuzzyFileFinderMoveSelection(delta) {
    if arrayLen(fuzzyFileFinderResults) == 0 {
        fuzzySelectedEntry = 0
        renderFuzzyFileFinder()
        return null
    }
    fuzzySelectedEntry = fuzzySelectedEntry + delta
    if fuzzySelectedEntry < 0 { fuzzySelectedEntry = arrayLen(fuzzyFileFinderResults) - 1 }
    if fuzzySelectedEntry >= arrayLen(fuzzyFileFinderResults) { fuzzySelectedEntry = 0 }
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderNext() {
    fuzzyFileFinderMoveSelection(1)
}

fn fuzzyFileFinderPrevious() {
    fuzzyFileFinderMoveSelection(-1)
}

fn fuzzyFileFinderSelect() {
    if fuzzySelectedEntry < arrayLen(fuzzyFileFinderResults) {
        path = arrayGet(fuzzyFileFinderResults, fuzzySelectedEntry)
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fuzzyFileFinderEscape() {
    if fuzzyFileFinderPreviousBufferId != -1 {
        setActiveBuffer(fuzzyFileFinderPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createFuzzyFileFinder() {
    fuzzyFileFinderPreviousBufferId = getActiveBuffer()
    if fuzzyFileFinderId == -1 {
        bufferId = createSpecialBuffer("Fuzzy File Finder")
        fuzzyFileFinderId = bufferId
        registerBufferKeybind(bufferId, "ins space", fuzzyFileFinderAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fuzzyFileFinderClearInput)
        registerBufferKeybind(bufferId, "ins tab", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins down", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins up", fuzzyFileFinderPrevious)
        registerBufferKeybind(bufferId, "ins enter", fuzzyFileFinderSelect)
        registerBufferKeybind(bufferId, "ins escape", fuzzyFileFinderEscape)
        registerBufferInputHook(bufferId, fuzzyFileFinderInputUpdated)
    }
    fuzzyFileFinderClearInput()
    setActiveBuffer(fuzzyFileFinderId)
    fuzzyFileFinderWorkspaceEntries()
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space f", createFuzzyFileFinder)

############

# Switch Buffer

switchBufferId = -1
switchBufferInput = ""
switchBufferResults = createArray()
switchBufferBuffers = createArray()
switchBufferSelectedEntry = 0
switchBufferSelectedId = -1
switchBufferPreviousBufferId = -1
switchBufferInitialActiveId = -1

fn switchBufferDisplay(entry) {
    display = tableGet(entry, "display_name")
    if tableGet(entry, "special") {
        display = "[special] " + display
    }
    if tableGet(entry, "modified") {
        display = display + " *"
    }
    if tableGet(entry, "is_active") {
        display = display + " (active)"
    }
    return display
}

fn renderSwitchBuffer() {
    content = "\n------\n" + switchBufferInput + "\n------\n"
    if arrayLen(switchBufferResults) == 0 {
        content = content + "\n   No buffers"
    }
    i = 0
    loop {
        if i >= arrayLen(switchBufferResults) { break }
        entry = arrayGet(switchBufferResults, i)
        display = switchBufferDisplay(entry)
        if switchBufferSelectedEntry == i {
            content = content + "\n > " + display
        } if switchBufferSelectedEntry != i {
            content = content + "\n   " + display
        }
        i = i + 1
    }
    setBufferContent(switchBufferId, content)
}

fn switchBufferLoadBuffers() {
    buffers = listBuffers()
    switchBufferBuffers = fromJson(buffers)
}

fn switchBufferUpdateSelectionFromId(targetId) {
    if arrayLen(switchBufferResults) == 0 {
        switchBufferSelectedEntry = 0
        switchBufferSelectedId = -1
        renderSwitchBuffer()
        return null
    }

    switchBufferSelectedEntry = 0
    i = 0
    loop {
        if i >= arrayLen(switchBufferResults) { break }
        entry = arrayGet(switchBufferResults, i)
        if tableGet(entry, "id") == targetId {
            switchBufferSelectedEntry = i
            break
        }
        i = i + 1
    }

    selectedEntry = arrayGet(switchBufferResults, switchBufferSelectedEntry)
    switchBufferSelectedId = tableGet(selectedEntry, "id")
    renderSwitchBuffer()
}

fn switchBufferUpdateResults() {
    switchBufferLoadBuffers()

    previousSelectionId = switchBufferSelectedId
    if previousSelectionId == -1 {
        previousSelectionId = switchBufferInitialActiveId
    }

    query = stringToLower(switchBufferInput)
    switchBufferResults = createArray()

    i = 0
    loop {
        if i >= arrayLen(switchBufferBuffers) { break }
        entry = arrayGet(switchBufferBuffers, i)
        name = stringToLower(tableGet(entry, "display_name"))
        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(switchBufferResults, entry)
        }
        i = i + 1
    }

    switchBufferSelectedId = -1
    switchBufferSelectedEntry = 0
    switchBufferUpdateSelectionFromId(previousSelectionId)
}

fn switchBufferInputUpdated() {
    switchBufferInput = getBufferInput(switchBufferId)
    switchBufferUpdateResults()
}

fn switchBufferAddSpace() {
    switchBufferInput = getBufferInput(switchBufferId)
    switchBufferInput = switchBufferInput + " "
    setBufferInput(switchBufferId, switchBufferInput)
    renderSwitchBuffer()
}

fn switchBufferClearInput() {
    switchBufferInput = ""
    setBufferInput(switchBufferId, switchBufferInput)
    renderSwitchBuffer()
}

fn switchBufferMoveSelection(delta) {
    if arrayLen(switchBufferResults) == 0 {
        switchBufferSelectedEntry = 0
        switchBufferSelectedId = -1
        renderSwitchBuffer()
        return null
    }
    switchBufferSelectedEntry = switchBufferSelectedEntry + delta
    if switchBufferSelectedEntry < 0 { switchBufferSelectedEntry = arrayLen(switchBufferResults) - 1 }
    if switchBufferSelectedEntry >= arrayLen(switchBufferResults) { switchBufferSelectedEntry = 0 }
    entry = arrayGet(switchBufferResults, switchBufferSelectedEntry)
    switchBufferSelectedId = tableGet(entry, "id")
    renderSwitchBuffer()
}

fn switchBufferNext() {
    switchBufferMoveSelection(1)
}

fn switchBufferPrevious() {
    switchBufferMoveSelection(-1)
}

fn switchBufferSelect() {
    if switchBufferSelectedEntry < arrayLen(switchBufferResults) {
        selection = arrayGet(switchBufferResults, switchBufferSelectedEntry)
        bufferId = tableGet(selection, "id")
        setActiveBuffer(bufferId)
        runAction("quit-insert-mode")
    }
}

fn switchBufferEscape() {
    if switchBufferPreviousBufferId != -1 {
        setActiveBuffer(switchBufferPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createSwitchBuffer() {
    switchBufferPreviousBufferId = getActiveBuffer()
    switchBufferInitialActiveId = switchBufferPreviousBufferId
    switchBufferSelectedId = -1

    if switchBufferId == -1 {
        bufferId = createSpecialBuffer("Switch Buffer")
        switchBufferId = bufferId
        registerBufferKeybind(bufferId, "ins space", switchBufferAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", switchBufferClearInput)
        registerBufferKeybind(bufferId, "ins tab", switchBufferNext)
        registerBufferKeybind(bufferId, "ins down", switchBufferNext)
        registerBufferKeybind(bufferId, "ins up", switchBufferPrevious)
        registerBufferKeybind(bufferId, "ins enter", switchBufferSelect)
        registerBufferKeybind(bufferId, "ins escape", switchBufferEscape)
        registerBufferInputHook(bufferId, switchBufferInputUpdated)
    }

    switchBufferClearInput()
    switchBufferUpdateResults()
    setActiveBuffer(switchBufferId)
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space b", createSwitchBuffer)

############

# Workspace Search

workspaceSearchId = -1
workspaceSearchInput = ""
workspaceSearchResults = createArray()
workspaceSearchSelectedEntry = 0
workspaceSearchPreviousBufferId = -1

fn renderWorkspaceSearch() {
    content = "\n------\n" + workspaceSearchInput + "\n------\n"
    if arrayLen(workspaceSearchResults) == 0 {
        content = content + "\n   No matches"
    }
    i = 0
    loop {
        if i >= arrayLen(workspaceSearchResults) { break }
        result = arrayGet(workspaceSearchResults, i)
        display = tableGet(result, "display")
        if workspaceSearchSelectedEntry == i {
            content = content + "\n > " + display
        } if workspaceSearchSelectedEntry != i {
            content = content + "\n   " + display
        }
        i = i + 1
    }
    setBufferContent(workspaceSearchId, content)
}

fn workspaceSearchClearInput() {
    workspaceSearchInput = ""
    setBufferInput(workspaceSearchId, workspaceSearchInput)
}

fn workspaceSearchUpdateResults() {
    workspaceSearchResults = createArray()
    if stringLen(workspaceSearchInput) <= 1 {
        workspaceSearchSelectedEntry = 0
        renderWorkspaceSearch()
        return null
    }

    results = runShellCommand("rg --json --color=never --smart-case --max-count 100 \"" + workspaceSearchInput + "\"", getWorkspaceDir())
    lines = stringSplitLines(tableGet(results, "stdout"))

    i = 0
    loop {
        if i >= arrayLen(lines) { break }
        line = arrayGet(lines, i)
        if line != "" {
            rgResult = fromJson(line)
            if tableGet(rgResult, "type") == "match" {
                data = tableGet(rgResult, "data")
                filePath = tableGet(tableGet(data, "path"), "text")
                row = tableGet(data, "line_number") - 1
                lineText = tableGet(tableGet(data, "lines"), "text")
                lineParts = stringSplitLines(lineText)
                if arrayLen(lineParts) > 0 {
                    lineText = arrayGet(lineParts, 0)
                }
                submatches = tableGet(data, "submatches")
                j = 0
                loop {
                    if j >= arrayLen(submatches) { break }
                    submatch = arrayGet(submatches, j)
                    start = tableGet(submatch, "start")
                    end = tableGet(submatch, "end")

                    display = filePath + ":" + toJson(row) + ":" + toJson(start) + " " + lineText

                    entry = createTable()
                    tableSet(entry, "file_path", filePath)
                    tableSet(entry, "row", row)
                    tableSet(entry, "start", start)
                    tableSet(entry, "end", end)
                    tableSet(entry, "display", display)
                    arrayPushBack(workspaceSearchResults, entry)
                    j = j + 1
                }
            }
        }
        i = i + 1
    }
    workspaceSearchSelectedEntry = 0
    renderWorkspaceSearch()
}

fn workspaceSearchInputUpdated() {
    workspaceSearchInput = getBufferInput(workspaceSearchId)
    workspaceSearchUpdateResults()
}

fn workspaceSearchAddSpace() {
    workspaceSearchInput = getBufferInput(workspaceSearchId)
    workspaceSearchInput = workspaceSearchInput + " "
    setBufferInput(workspaceSearchId, workspaceSearchInput)
    renderWorkspaceSearch()
}

fn workspaceSearchMoveSelection(delta) {
    if arrayLen(workspaceSearchResults) == 0 {
        workspaceSearchSelectedEntry = 0
        renderWorkspaceSearch()
        return null
    }
    workspaceSearchSelectedEntry = workspaceSearchSelectedEntry + delta
    if workspaceSearchSelectedEntry < 0 { workspaceSearchSelectedEntry = arrayLen(workspaceSearchResults) - 1 }
    if workspaceSearchSelectedEntry >= arrayLen(workspaceSearchResults) { workspaceSearchSelectedEntry = 0 }
    renderWorkspaceSearch()
}

fn workspaceSearchNext() {
    workspaceSearchMoveSelection(1)
}

fn workspaceSearchPrevious() {
    workspaceSearchMoveSelection(-1)
}

fn workspaceSearchSelect() {
    if workspaceSearchSelectedEntry < arrayLen(workspaceSearchResults) {
        selection = arrayGet(workspaceSearchResults, workspaceSearchSelectedEntry)
        path = tableGet(selection, "file_path")
        row = tableGet(selection, "row")
        start = tableGet(selection, "start")
        end = tableGet(selection, "end")

        openFile(path)
        runAction("quit-insert-mode")
        runAction("go-to-buffer-start")

        i = 0
        loop {
            if i >= row { break }
            runAction("move-cursor-down")
            i = i + 1
        }

        runAction("move-cursor-line-start")

        j = 0
        loop {
            if j >= start { break }
            runAction("move-cursor-right")
            j = j + 1
        }

        length = end - start
        k = 0
        loop {
            if k >= length { break }
            runAction("extend-cursor-right")
            k = k + 1
        }

        runAction("quit-insert-mode")
    }
}

fn workspaceSearchEscape() {
    if workspaceSearchPreviousBufferId != -1 {
        setActiveBuffer(workspaceSearchPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createWorkspaceSearch() {
    workspaceSearchPreviousBufferId = getActiveBuffer()
    if workspaceSearchId == -1 {
        bufferId = createSpecialBuffer("Workspace Search")
        workspaceSearchId = bufferId
        registerBufferKeybind(bufferId, "ins space", workspaceSearchAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceSearchClearInput)
        registerBufferKeybind(bufferId, "ins tab", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins down", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins up", workspaceSearchPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceSearchSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceSearchEscape)
        registerBufferInputHook(bufferId, workspaceSearchInputUpdated)
    }
    workspaceSearchClearInput()
    setActiveBuffer(workspaceSearchId)
    workspaceSearchUpdateResults()
    runAction("enter-insert-mode")
}

############

# Workspace Diagnostics

workspaceDiagnosticsId = -1
workspaceDiagnosticsInput = ""
workspaceDiagnosticsAll = createArray()
workspaceDiagnosticsResults = createArray()
workspaceDiagnosticsSelectedEntry = 0
workspaceDiagnosticsPreviousBufferId = -1

fn workspaceDiagnosticsDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    severity = tableGet(entry, "severity")
    source = tableGet(entry, "source")
    code = tableGet(entry, "code")
    message = tableGet(entry, "message")

    if source == "null" { source = "" }
    if code == "null" { code = "" }

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    details = source
    if stringLen(code) > 0 {
        details = details + " " + code
    }

    if stringLen(details) > 0 {
        return "[" + severity + "] " + location + " (" + details + ") " + message
    }

    return "[" + severity + "] " + location + " " + message
}

fn renderWorkspaceDiagnostics() {
    content = "\n------\n" + workspaceDiagnosticsInput + "\n------\n"
    if arrayLen(workspaceDiagnosticsResults) == 0 {
        content = content + "\n   No diagnostics"
    }
    i = 0
    loop {
        if i >= arrayLen(workspaceDiagnosticsResults) { break }
        entry = arrayGet(workspaceDiagnosticsResults, i)
        display = workspaceDiagnosticsDisplay(entry)
        if workspaceDiagnosticsSelectedEntry == i {
            content = content + "\n > " + display
        } if workspaceDiagnosticsSelectedEntry != i {
            content = content + "\n   " + display
        }
        i = i + 1
    }
    setBufferContent(workspaceDiagnosticsId, content)
}

fn workspaceDiagnosticsFilterResults() {
    workspaceDiagnosticsResults = createArray()
    query = stringToLower(workspaceDiagnosticsInput)

    i = 0
    loop {
        if i >= arrayLen(workspaceDiagnosticsAll) { break }
        entry = arrayGet(workspaceDiagnosticsAll, i)

        message = stringToLower(tableGet(entry, "message"))
        filePath = stringToLower(tableGet(entry, "file_path"))
        severity = stringToLower(tableGet(entry, "severity"))
        source = stringToLower(tableGet(entry, "source"))

        if stringLen(query) == 0 or stringContains(message, query) or stringContains(filePath, query) or stringContains(severity, query) or stringContains(source, query) {
            arrayPushBack(workspaceDiagnosticsResults, entry)
        }
        i = i + 1
    }

    workspaceDiagnosticsSelectedEntry = 0
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsInputUpdated() {
    workspaceDiagnosticsInput = getBufferInput(workspaceDiagnosticsId)
    workspaceDiagnosticsFilterResults()
}

fn workspaceDiagnosticsAddSpace() {
    workspaceDiagnosticsInput = getBufferInput(workspaceDiagnosticsId)
    workspaceDiagnosticsInput = workspaceDiagnosticsInput + " "
    setBufferInput(workspaceDiagnosticsId, workspaceDiagnosticsInput)
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsClearInput() {
    workspaceDiagnosticsInput = ""
    setBufferInput(workspaceDiagnosticsId, workspaceDiagnosticsInput)
}

fn workspaceDiagnosticsMoveSelection(delta) {
    if arrayLen(workspaceDiagnosticsResults) == 0 {
        workspaceDiagnosticsSelectedEntry = 0
        renderWorkspaceDiagnostics()
        return null
    }
    workspaceDiagnosticsSelectedEntry = workspaceDiagnosticsSelectedEntry + delta
    if workspaceDiagnosticsSelectedEntry < 0 { workspaceDiagnosticsSelectedEntry = arrayLen(workspaceDiagnosticsResults) - 1 }
    if workspaceDiagnosticsSelectedEntry >= arrayLen(workspaceDiagnosticsResults) { workspaceDiagnosticsSelectedEntry = 0 }
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsNext() {
    workspaceDiagnosticsMoveSelection(1)
}

fn workspaceDiagnosticsPrevious() {
    workspaceDiagnosticsMoveSelection(-1)
}

fn workspaceDiagnosticsSelect() {
    if workspaceDiagnosticsSelectedEntry < arrayLen(workspaceDiagnosticsResults) {
        entry = arrayGet(workspaceDiagnosticsResults, workspaceDiagnosticsSelectedEntry)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceDiagnosticsEscape() {
    if workspaceDiagnosticsPreviousBufferId != -1 {
        setActiveBuffer(workspaceDiagnosticsPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn workspaceDiagnosticsReload() {
    diagnostics = getWorkspaceDiagnostics()
    workspaceDiagnosticsAll = fromJson(diagnostics)
    workspaceDiagnosticsFilterResults()
}

fn createWorkspaceDiagnostics() {
    workspaceDiagnosticsPreviousBufferId = getActiveBuffer()
    if workspaceDiagnosticsId == -1 {
        bufferId = createSpecialBuffer("Workspace Diagnostics")
        workspaceDiagnosticsId = bufferId
        registerBufferKeybind(bufferId, "ins space", workspaceDiagnosticsAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceDiagnosticsClearInput)
        registerBufferKeybind(bufferId, "ins tab", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins down", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins up", workspaceDiagnosticsPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceDiagnosticsSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceDiagnosticsEscape)
        registerBufferInputHook(bufferId, workspaceDiagnosticsInputUpdated)
    }
    workspaceDiagnosticsClearInput()
    workspaceDiagnosticsReload()
    setActiveBuffer(workspaceDiagnosticsId)
    runAction("enter-insert-mode")
}

############

# Command Dispatcher

commandDispatcherId = -1
commandDispatcherInput = ""
commandDispatcherAll = createArray()
commandDispatcherResults = createArray()
commandDispatcherSelectedEntry = 0
commandDispatcherPreviousBufferId = -1

fn renderCommandDispatcher() {
    content = "\n------\n" + commandDispatcherInput + "\n------\n"
    if arrayLen(commandDispatcherResults) == 0 {
        content = content + "\n   No commands"
    }
    i = 0
    loop {
        if i >= arrayLen(commandDispatcherResults) { break }
        action = arrayGet(commandDispatcherResults, i)
        if commandDispatcherSelectedEntry == i {
            content = content + "\n > " + action
        } if commandDispatcherSelectedEntry != i {
            content = content + "\n   " + action
        }
        i = i + 1
    }
    setBufferContent(commandDispatcherId, content)
}

fn commandDispatcherFilterResults() {
    commandDispatcherResults = createArray()
    query = stringToLower(commandDispatcherInput)

    i = 0
    loop {
        if i >= arrayLen(commandDispatcherAll) { break }
        action = arrayGet(commandDispatcherAll, i)
        actionLower = stringToLower(action)

        if stringLen(query) == 0 or stringContains(actionLower, query) {
            arrayPushBack(commandDispatcherResults, action)
        }
        i = i + 1
    }

    commandDispatcherSelectedEntry = 0
    renderCommandDispatcher()
}

fn commandDispatcherInputUpdated() {
    commandDispatcherInput = getBufferInput(commandDispatcherId)
    commandDispatcherFilterResults()
}

fn commandDispatcherAddSpace() {
    commandDispatcherInput = getBufferInput(commandDispatcherId)
    commandDispatcherInput = commandDispatcherInput + " "
    setBufferInput(commandDispatcherId, commandDispatcherInput)
    renderCommandDispatcher()
}

fn commandDispatcherClearInput() {
    commandDispatcherInput = ""
    setBufferInput(commandDispatcherId, commandDispatcherInput)
}

fn commandDispatcherMoveSelection(delta) {
    if arrayLen(commandDispatcherResults) == 0 {
        commandDispatcherSelectedEntry = 0
        renderCommandDispatcher()
        return null
    }
    commandDispatcherSelectedEntry = commandDispatcherSelectedEntry + delta
    if commandDispatcherSelectedEntry < 0 { commandDispatcherSelectedEntry = arrayLen(commandDispatcherResults) - 1 }
    if commandDispatcherSelectedEntry >= arrayLen(commandDispatcherResults) { commandDispatcherSelectedEntry = 0 }
    renderCommandDispatcher()
}

fn commandDispatcherNext() {
    commandDispatcherMoveSelection(1)
}

fn commandDispatcherPrevious() {
    commandDispatcherMoveSelection(-1)
}

fn commandDispatcherSelect() {
    if commandDispatcherSelectedEntry < arrayLen(commandDispatcherResults) {
        action = arrayGet(commandDispatcherResults, commandDispatcherSelectedEntry)
        if commandDispatcherPreviousBufferId != -1 {
            setActiveBuffer(commandDispatcherPreviousBufferId)
        }
        runAction("quit-insert-mode")
        runAction(action)
    }
}

fn commandDispatcherEscape() {
    if commandDispatcherPreviousBufferId != -1 {
        setActiveBuffer(commandDispatcherPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn commandDispatcherReload() {
    actions = getActions()
    commandDispatcherAll = fromJson(actions)
    commandDispatcherFilterResults()
}

fn createCommandDispatcher() {
    commandDispatcherPreviousBufferId = getActiveBuffer()
    if commandDispatcherId == -1 {
        bufferId = createSpecialBuffer("Command Dispatcher")
        commandDispatcherId = bufferId
        registerBufferKeybind(bufferId, "ins space", commandDispatcherAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", commandDispatcherClearInput)
        registerBufferKeybind(bufferId, "ins tab", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins down", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins up", commandDispatcherPrevious)
        registerBufferKeybind(bufferId, "ins enter", commandDispatcherSelect)
        registerBufferKeybind(bufferId, "ins escape", commandDispatcherEscape)
        registerBufferInputHook(bufferId, commandDispatcherInputUpdated)
    }
    commandDispatcherClearInput()
    commandDispatcherReload()
    setActiveBuffer(commandDispatcherId)
    runAction("enter-insert-mode")
}

############

# Go To Definition

goToDefinitionId = -1
goToDefinitionInput = ""
goToDefinitionAll = createArray()
goToDefinitionResults = createArray()
goToDefinitionSelectedEntry = 0
goToDefinitionPreviousBufferId = -1

fn goToDefinitionDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    preview = tableGet(entry, "preview")

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToDefinition() {
    content = "\n------\n" + goToDefinitionInput + "\n------\n"
    if arrayLen(goToDefinitionResults) == 0 {
        content = content + "\n   No definitions"
    }
    i = 0
    loop {
        if i >= arrayLen(goToDefinitionResults) { break }
        entry = arrayGet(goToDefinitionResults, i)
        display = goToDefinitionDisplay(entry)
        if goToDefinitionSelectedEntry == i {
            content = content + "\n > " + display
        } if goToDefinitionSelectedEntry != i {
            content = content + "\n   " + display
        }
        i = i + 1
    }
    setBufferContent(goToDefinitionId, content)
}

fn goToDefinitionFilterResults() {
    goToDefinitionResults = createArray()
    query = stringToLower(goToDefinitionInput)

    i = 0
    loop {
        if i >= arrayLen(goToDefinitionAll) { break }
        entry = arrayGet(goToDefinitionAll, i)

        filePath = stringToLower(tableGet(entry, "file_path"))
        preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(goToDefinitionResults, entry)
        }
        i = i + 1
    }

    goToDefinitionSelectedEntry = 0
    renderGoToDefinition()
}

fn goToDefinitionInputUpdated() {
    goToDefinitionInput = getBufferInput(goToDefinitionId)
    goToDefinitionFilterResults()
}

fn goToDefinitionAddSpace() {
    goToDefinitionInput = getBufferInput(goToDefinitionId)
    goToDefinitionInput = goToDefinitionInput + " "
    setBufferInput(goToDefinitionId, goToDefinitionInput)
    renderGoToDefinition()
}

fn goToDefinitionClearInput() {
    goToDefinitionInput = ""
    setBufferInput(goToDefinitionId, goToDefinitionInput)
}

fn goToDefinitionMoveSelection(delta) {
    if arrayLen(goToDefinitionResults) == 0 {
        goToDefinitionSelectedEntry = 0
        renderGoToDefinition()
        return null
    }
    goToDefinitionSelectedEntry = goToDefinitionSelectedEntry + delta
    if goToDefinitionSelectedEntry < 0 { goToDefinitionSelectedEntry = arrayLen(goToDefinitionResults) - 1 }
    if goToDefinitionSelectedEntry >= arrayLen(goToDefinitionResults) { goToDefinitionSelectedEntry = 0 }
    renderGoToDefinition()
}

fn goToDefinitionNext() {
    goToDefinitionMoveSelection(1)
}

fn goToDefinitionPrevious() {
    goToDefinitionMoveSelection(-1)
}

fn goToDefinitionSelect() {
    if goToDefinitionSelectedEntry < arrayLen(goToDefinitionResults) {
        entry = arrayGet(goToDefinitionResults, goToDefinitionSelectedEntry)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToDefinitionEscape() {
    if goToDefinitionPreviousBufferId != -1 {
        setActiveBuffer(goToDefinitionPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToDefinitionReload() {
    definitions = getDefinitions()
    goToDefinitionAll = fromJson(definitions)
    goToDefinitionFilterResults()
}

fn createGoToDefinition() {
    goToDefinitionPreviousBufferId = getActiveBuffer()
    if goToDefinitionId == -1 {
        bufferId = createSpecialBuffer("Definitions")
        goToDefinitionId = bufferId
        registerBufferKeybind(bufferId, "ins space", goToDefinitionAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToDefinitionClearInput)
        registerBufferKeybind(bufferId, "ins tab", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins down", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins up", goToDefinitionPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToDefinitionSelect)
        registerBufferKeybind(bufferId, "ins escape", goToDefinitionEscape)
        registerBufferInputHook(bufferId, goToDefinitionInputUpdated)
    }
    goToDefinitionClearInput()
    goToDefinitionReload()
    setActiveBuffer(goToDefinitionId)
    runAction("enter-insert-mode")
}

# Go To References

goToReferencesId = -1
goToReferencesInput = ""
goToReferencesAll = createArray()
goToReferencesResults = createArray()
goToReferencesSelectedEntry = 0
goToReferencesPreviousBufferId = -1

fn goToReferencesDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    preview = tableGet(entry, "preview")

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToReferences() {
    content = "\n------\n" + goToReferencesInput + "\n------\n"
    if arrayLen(goToReferencesResults) == 0 {
        content = content + "\n   No references"
    }
    i = 0
    loop {
        if i >= arrayLen(goToReferencesResults) { break }
        entry = arrayGet(goToReferencesResults, i)
        display = goToReferencesDisplay(entry)
        if goToReferencesSelectedEntry == i {
            content = content + "\n > " + display
        } if goToReferencesSelectedEntry != i {
            content = content + "\n   " + display
        }
        i = i + 1
    }
    setBufferContent(goToReferencesId, content)
}

fn goToReferencesFilterResults() {
    goToReferencesResults = createArray()
    query = stringToLower(goToReferencesInput)

    i = 0
    loop {
        if i >= arrayLen(goToReferencesAll) { break }
        entry = arrayGet(goToReferencesAll, i)

        filePath = stringToLower(tableGet(entry, "file_path"))
        preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(goToReferencesResults, entry)
        }
        i = i + 1
    }

    goToReferencesSelectedEntry = 0
    renderGoToReferences()
}

fn goToReferencesInputUpdated() {
    goToReferencesInput = getBufferInput(goToReferencesId)
    goToReferencesFilterResults()
}

fn goToReferencesAddSpace() {
    goToReferencesInput = getBufferInput(goToReferencesId)
    goToReferencesInput = goToReferencesInput + " "
    setBufferInput(goToReferencesId, goToReferencesInput)
    renderGoToReferences()
}

fn goToReferencesClearInput() {
    goToReferencesInput = ""
    setBufferInput(goToReferencesId, goToReferencesInput)
}

fn goToReferencesMoveSelection(delta) {
    if arrayLen(goToReferencesResults) == 0 {
        goToReferencesSelectedEntry = 0
        renderGoToReferences()
        return null
    }
    goToReferencesSelectedEntry = goToReferencesSelectedEntry + delta
    if goToReferencesSelectedEntry < 0 { goToReferencesSelectedEntry = arrayLen(goToReferencesResults) - 1 }
    if goToReferencesSelectedEntry >= arrayLen(goToReferencesResults) { goToReferencesSelectedEntry = 0 }
    renderGoToReferences()
}

fn goToReferencesNext() {
    goToReferencesMoveSelection(1)
}

fn goToReferencesPrevious() {
    goToReferencesMoveSelection(-1)
}

fn goToReferencesSelect() {
    if goToReferencesSelectedEntry < arrayLen(goToReferencesResults) {
        entry = arrayGet(goToReferencesResults, goToReferencesSelectedEntry)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToReferencesEscape() {
    if goToReferencesPreviousBufferId != -1 {
        setActiveBuffer(goToReferencesPreviousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToReferencesReload() {
    references = getReferences()
    goToReferencesAll = fromJson(references)
    goToReferencesFilterResults()
}

fn createGoToReferences() {
    goToReferencesPreviousBufferId = getActiveBuffer()
    if goToReferencesId == -1 {
        bufferId = createSpecialBuffer("References")
        goToReferencesId = bufferId
        registerBufferKeybind(bufferId, "ins space", goToReferencesAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToReferencesClearInput)
        registerBufferKeybind(bufferId, "ins tab", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins down", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins up", goToReferencesPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToReferencesSelect)
        registerBufferKeybind(bufferId, "ins escape", goToReferencesEscape)
        registerBufferInputHook(bufferId, goToReferencesInputUpdated)
    }
    goToReferencesClearInput()
    goToReferencesReload()
    setActiveBuffer(goToReferencesId)
    runAction("enter-insert-mode")
}

############

# Info Modal

infoModalId = -1
infoModalPreviousBufferId = -1
infoModalLines = createArray()
infoModalScroll = 0
infoModalActive = false
infoModalPageSize = 48

fn infoModalClampScroll() {
    maxScroll = arrayLen(infoModalLines) - infoModalPageSize
    if maxScroll < 0 { maxScroll = 0 }
    if infoModalScroll < 0 { infoModalScroll = 0 }
    if infoModalScroll > maxScroll { infoModalScroll = maxScroll }
}

fn infoModalRender() {
    infoModalClampScroll()
    content = "Info Modal (esc to close, up/down to scroll)\n------\n"

    totalLines = arrayLen(infoModalLines)
    if totalLines == 0 {
        content = content + "\n   No information available"
        setBufferContent(infoModalId, content)
        return null
    }

    start = infoModalScroll
    end = start + infoModalPageSize
    if end > totalLines { end = totalLines }

    i = start
    loop {
        if i >= end { break }
        content = content + "\n" + arrayGet(infoModalLines, i)
        i = i + 1
    }

    if end < totalLines {
        remaining = totalLines - end
        content = content + "\n\n... (" + toJson(remaining) + " more lines)"
    }

    setBufferContent(infoModalId, content)
}

fn infoModalEnsureBuffer() {
    if infoModalId == -1 {
        bufferId = createSpecialBuffer("Info")
        infoModalId = bufferId
        registerBufferKeybind(bufferId, "ins escape", infoModalClose)
        registerBufferKeybind(bufferId, "ins up", infoModalScrollUp)
        registerBufferKeybind(bufferId, "ins down", infoModalScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", infoModalPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", infoModalPageDown)
    }
}

fn infoModalOpen(content) {
    infoModalEnsureBuffer()
    if !infoModalActive {
        infoModalPreviousBufferId = getActiveBuffer()
    }
    infoModalActive = true
    infoModalLines = stringSplitLines(content)
    infoModalScroll = 0
    infoModalRender()
    setActiveBuffer(infoModalId)
    setBufferInput(infoModalId, "")
    runAction("enter-insert-mode")
}

fn infoModalClose() {
    infoModalActive = false
    infoModalScroll = 0
    if infoModalPreviousBufferId != -1 {
        setActiveBuffer(infoModalPreviousBufferId)
    }
    runAction("quit-insert-mode")
}

fn infoModalScrollUp() {
    if !infoModalActive { return null }
    infoModalScroll = infoModalScroll - 1
    infoModalRender()
}

fn infoModalScrollDown() {
    if !infoModalActive { return null }
    infoModalScroll = infoModalScroll + 1
    infoModalRender()
}

fn infoModalPageUp() {
    if !infoModalActive { return null }
    infoModalScroll = infoModalScroll - infoModalPageSize
    infoModalRender()
}

fn infoModalPageDown() {
    if !infoModalActive { return null }
    infoModalScroll = infoModalScroll + infoModalPageSize
    infoModalRender()
}
