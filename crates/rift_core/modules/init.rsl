# Callbacks

fn onViewportSizeChanged(rows, columns) {
    setViewportSize(rows, columns)
}

# UI Helper Methods

fn setViewportSize(rows, columns) {
    viewportRows = rows
    viewportColumns = columns
    rerenderAllUi()
}

fn refreshViewportSize() {
    let size = fromJson(getViewportSize())
    setViewportSize(tableGet(size, "rows"), tableGet(size, "columns"))
}

fn viewportVisibleRows(reservedLines) {
    # Keep a reasonable default even if the viewport has not reported yet.
    let available = viewportRows - reservedLines
    if available < 5 { available = 5 }
    return available
}

fn viewportVisibleColumns() {
    # Rendering reserves 3 columns (see RopeBuffer::get_visible_lines); clamp to visible width.
    let columns = viewportColumns
    if columns <= 0 { columns = 20 }
    columns = columns - 3
    if columns < 1 { columns = 1 }
    return columns
}

fn clampLineToViewport(line, columns) {
    if columns <= 0 { return "" }
    if stringWidth(line) <= columns { return line }

    let ellipsis = "â€¦"
    let ellipsisWidth = stringWidth(ellipsis)

    if ellipsisWidth >= columns { return stringTruncateWidth(ellipsis, columns) }

    let available = columns - ellipsisWidth
    if available < 0 { available = 0 }
    return stringTruncateWidth(line, available) + ellipsis
}

fn clampContentToViewport(content) {
    let columns = viewportVisibleColumns()
    let lines = stringSplitLines(content)
    let clamped = ""

    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = arrayGet(lines, i)
        let clampedLine = clampLineToViewport(line, columns)
        if i > 0 { clamped = clamped + "\n" }
        clamped = clamped + clampedLine
        i = i + 1
    }

    return clamped
}

fn setViewportBufferContent(bufferId, content) {
    setBufferContent(bufferId, clampContentToViewport(content))
}

fn viewportWindow(selectedIndex, totalItems, reservedLines) {
    let window = createTable()
    if totalItems <= 0 {
        tableSet(window, "start", 0)
        tableSet(window, "end", 0)
        return window
    }

    let visible = viewportVisibleRows(reservedLines)
    if visible > totalItems { visible = totalItems }

    let start = floor(selectedIndex - (visible / 2))
    if start < 0 { start = 0 }
    let end = start + visible
    if end > totalItems {
        end = totalItems
        start = end - visible
        if start < 0 { start = 0 }
    }

    tableSet(window, "start", start)
    tableSet(window, "end", end)
    return window
}

# Shared List + Input Helpers

fn listPanelMoveSelection(entries, selectedIndex, delta) {
    let total = arrayLen(entries)
    if total == 0 { return 0 }
    let nextIndex = selectedIndex + delta
    if nextIndex < 0 { nextIndex = total - 1 }
    if nextIndex >= total { nextIndex = 0 }
    return nextIndex
}

fn listPanelRender(ctx) {
    let title = tableGet(ctx, "title")
    let inputHeader = tableGet(ctx, "input_header")
    let inputValue = tableGet(ctx, "input_value")
    let listHeader = tableGet(ctx, "list_header")
    let entries = tableGet(ctx, "entries")
    let selectedIndex = tableGet(ctx, "selected_index")
    let reservedLines = tableGet(ctx, "reserved_lines")
    let emptyText = tableGet(ctx, "empty_text")
    let bufferId = tableGet(ctx, "buffer_id")
    let entryToString = tableGet(ctx, "entry_to_string")
    let headerLines = tableGet(ctx, "header_lines")
    let extraLines = tableGet(ctx, "extra_lines")

    let content = title
    if headerLines != null {
        let i = 0
        loop {
            if i >= arrayLen(headerLines) { break }
            content = content + "\n" + arrayGet(headerLines, i)
            i = i + 1
        }
    }

    content = content + "\n" + inputHeader + "\n" + inputValue + "\n" + listHeader

    if extraLines != null {
        let i = 0
        loop {
            if i >= arrayLen(extraLines) { break }
            content = content + "\n" + arrayGet(extraLines, i)
            i = i + 1
        }
    }

    let total = arrayLen(entries)
    if total == 0 {
        content = content + "\n   " + emptyText
        setViewportBufferContent(bufferId, content)
        return null
    }

    if reservedLines == null { reservedLines = 5 }
    let window = viewportWindow(selectedIndex, total, reservedLines)
    let start = tableGet(window, "start")
    let end = tableGet(window, "end")

    if start > 0 { content = content + "\n   â‹¯" }

    let i = start
    loop {
        if i >= end { break }
        let entry = arrayGet(entries, i)
        let display = entry
        if entryToString != null {
            display = entryToString(entry)
        }
        let prefix = "â€¢"
        if selectedIndex == i { prefix = "âž¤" }
        content = content + "\n " + prefix + " " + display
        i = i + 1
    }

    if end < total { content = content + "\n   â‹¯" }

    setViewportBufferContent(bufferId, content)
}

fn inputGet(bufferId) {
    return getBufferInput(bufferId)
}

fn inputSet(bufferId, value) {
    setBufferInput(bufferId, value)
}

fn inputUpdated(bufferId, stateTable, key, onUpdated) {
    let value = getBufferInput(bufferId)
    tableSet(stateTable, key, value)
    if onUpdated != null { onUpdated() }
}

fn inputAddSpace(bufferId, stateTable, key, onUpdated) {
    let value = getBufferInput(bufferId)
    value = value + " "
    tableSet(stateTable, key, value)
    setBufferInput(bufferId, value)
    if onUpdated != null { onUpdated() }
}

fn inputBackspace(bufferId, stateTable, key, onCleared) {
    let value = getBufferInput(bufferId)
    let length = stringLen(value)
    if length <= 0 { return null }
    value = stringTruncateWidth(value, length - 1)
    tableSet(stateTable, key, value)
    setBufferInput(bufferId, value)
    if onCleared != null { onCleared() }
}

fn inputClear(bufferId, stateTable, key, onCleared) {
    tableSet(stateTable, key, "")
    setBufferInput(bufferId, "")
    if onCleared != null { onCleared() }
}

# Dashboard

let viewportRows = 0
let viewportColumns = 0
let dashboard = createTable()
tableSet(dashboard, "id", -1)
tableSet(dashboard, "text", "
Welcome to rift!

Basic Keybinds:

esc - Quit Insert Mode
i - Enter Insert Mode
space q - Quit
space f - Fuzzy File Picker (with fd & fzf)
space F - File Explorer
space b - Switch Buffer
")

fn renderDashboard() {
    let dashboardId = tableGet(dashboard, "id")
    if dashboardId == -1 { return null }
    let content = tableGet(dashboard, "text") + "\nViewport: " + toString(viewportRows) + " x " + toString(viewportColumns)
    setViewportBufferContent(dashboardId, content)
}

fn createDashboardBuffer() {
    let dashboardId = tableGet(dashboard, "id")
    if dashboardId == -1 {
        let bufferId = createSpecialBuffer("Dashboard")
        tableSet(dashboard, "id", bufferId)
        let activeBuffer = getActiveBuffer()
        if activeBuffer == null {
            setActiveBuffer(bufferId)
        }
    }
    renderDashboard()
}

#################

# Agentic Chat

fn toolDeclarations() {
    return
"[
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"run_shell_command\",
            \"description\": \"Run a shell command and return the output\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"command\": {\"type\": \"string\"}
                },
                \"required\": [\"command\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"find_file\",
            \"description\": \"Returns paths matching regex pattern by searching recursively in the workspace folder, returning absolute paths. Does not accept glob patterns.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"search_workspace\",
            \"description\": \"Grep search in the current workspace for matching patterns\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"read_file\",
            \"description\": \"Get the content of a file with line numbers\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"path\": {\"type\": \"string\"}
                },
                \"required\": [\"path\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"write_file\",
            \"description\": \"Writes content to a specified file replacing the existing content.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"content\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"content\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"replace\",
            \"description\": \"Replaces text within a file. Can replace single or multiple occurrences.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"old_string\": {\"type\": \"string\"},
                    \"new_string\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"old_string\", \"new_string\"]
            }
        }
    }
]"
}

fn agentRunShellCommand(command) {
    let outputs = runShellCommand(command, getWorkspaceDir())
    return "STDOUT:\n" + tableGet(outputs, "stdout") + "\nSTDERR:\n" + tableGet(outputs, "stderr")
}

fn agentFindFile(pattern) {
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

fn agentSearchWorkspace(pattern) {
    let results = runShellCommand("rg " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

fn getOpenRouterProvider() {
    let provider = createTable()
    tableSet(provider, "url", "https://openrouter.ai/api/v1/chat/completions")
    tableSet(provider, "api_key", getEnvVar("OPENROUTER_KEY"))
    tableSet(provider, "model", "mistralai/devstral-small")
    return provider
}

fn getLlamaCppProvider() {
    let provider = createTable()
    tableSet(provider, "url", "http://127.0.0.1:8080/v1/chat/completions")
    tableSet(provider, "api_key", null)
    tableSet(provider, "model", "Granite-4.0-H-Tiny")
    return provider
}

let openRouterProvider = getOpenRouterProvider()
let llamaCppProvider = getLlamaCppProvider()

let llmChat = createTable()
tableSet(llmChat, "id", -1)
tableSet(llmChat, "provider", llamaCppProvider)
tableSet(llmChat, "history_scroll", 0)
tableSet(llmChat, "history_page_size", 1)
tableSet(llmChat, "input", "")
tableSet(llmChat, "history", createArray())
tableSet(llmChat, "pending_tool_calls", createArray())

fn llmChatRoleLabel(message) {
    let role = tableGet(message, "role")
    let label = role
    if role == "assistant" { label = "Assistant" }
    if role == "user" { label = "User" }
    if role == "system" { label = "System" }
    if role == "tool" {
        label = "Tool"
        let name = tableGet(message, "name")
        if name != null {
            label = "Tool (" + name + ")"
        }
    }
    return label
}

fn llmChatToolCallName(toolCall) {
    let toolFunc = tableGet(toolCall, "function")
    if toolFunc == null { return "unknown" }
    let name = tableGet(toolFunc, "name")
    if name == null { return "unknown" }
    return name
}

fn llmChatLinesToString(lines) {
    let text = ""
    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = arrayGet(lines, i)
        if i > 0 { text = text + "\n" }
        text = text + line
        i = i + 1
    }
    return text
}

fn llmChatScrollUp() {
    let llmChatHistoryScroll = tableGet(llmChat, "history_scroll") + 1
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatScrollDown() {
    let llmChatHistoryScroll = tableGet(llmChat, "history_scroll") - 1
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatPageUp() {
    let llmChatHistoryScroll = tableGet(llmChat, "history_scroll") + tableGet(llmChat, "history_page_size")
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatPageDown() {
    let llmChatHistoryScroll = tableGet(llmChat, "history_scroll") - tableGet(llmChat, "history_page_size")
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn renderLLMChat() {
    let chatHistory = tableGet(llmChat, "history")
    let historyLines = createArray()
    let totalMessages = arrayLen(chatHistory)
    let i = 0
    loop {
        if i >= totalMessages { break }
        let message = arrayGet(chatHistory, i)
        let label = llmChatRoleLabel(message)
        arrayPushBack(historyLines, label + ":")
        let content = tableGet(message, "content")
        if content == null { content = "" }
        let contentLines = stringSplitLines(content)
        if arrayLen(contentLines) == 0 or stringLen(content) == 0 {
            arrayPushBack(historyLines, "  (empty)")
        }
        if arrayLen(contentLines) != 0 and stringLen(content) != 0 {
            let j = 0
            loop {
                if j >= arrayLen(contentLines) { break }
                let line = arrayGet(contentLines, j)
                arrayPushBack(historyLines, "  " + line)
                j = j + 1
            }
        }
        let toolCalls = tableGet(message, "tool_calls")
        if toolCalls != null {
            let j = 0
            loop {
                if j >= arrayLen(toolCalls) { break }
                let toolCall = arrayGet(toolCalls, j)
                let toolName = llmChatToolCallName(toolCall)
                arrayPushBack(historyLines, "  â€¢ tool call: " + toolName)
                j = j + 1
            }
        }
        if i < totalMessages - 1 {
            arrayPushBack(historyLines, "")
        }
        i = i + 1
    }

    let historyContent = ""
    if arrayLen(historyLines) == 0 {
        historyContent = "   No messages yet"
    }
    if arrayLen(historyLines) != 0 {
        historyContent = llmChatLinesToString(historyLines)
    }

    let pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    let pendingLines = createArray()
    if arrayLen(pendingToolCalls) == 0 {
        arrayPushBack(pendingLines, "   None")
    }
    if arrayLen(pendingToolCalls) != 0 {
        let i = 0
        loop {
            if i >= arrayLen(pendingToolCalls) { break }
            let toolCall = arrayGet(pendingToolCalls, i)
            let toolName = llmChatToolCallName(toolCall)
            arrayPushBack(pendingLines, " â€¢ " + toolName)
            i = i + 1
        }
    }

    let chatInput = tableGet(llmChat, "input")
    let inputLines = stringSplitLines(chatInput)
    if arrayLen(inputLines) == 0 or stringLen(chatInput) == 0 {
        inputLines = createArray()
        arrayPushBack(inputLines, "Type a message...")
    }

    let headerLines = 3
    let sectionLines = 3
    let reservedLines = headerLines + sectionLines + arrayLen(pendingLines) + arrayLen(inputLines)
    let historyRows = viewportVisibleRows(reservedLines)
    if historyRows < 1 { historyRows = 1 }

    let columns = viewportVisibleColumns()
    let wrappedAll = stringRenderViewport(historyContent, columns, 100000, 0)
    let wrappedLines = stringSplitLines(wrappedAll)
    let totalHistoryLines = arrayLen(wrappedLines)
    if totalHistoryLines < 1 { totalHistoryLines = 1 }

    let llmChatHistoryScroll = tableGet(llmChat, "history_scroll")
    let showEllipsis = llmChatHistoryScroll > 0
    if showEllipsis and historyRows <= 1 { showEllipsis = false }
    if showEllipsis { historyRows = historyRows - 1 }

    let maxScroll = totalHistoryLines - historyRows
    if maxScroll < 0 { maxScroll = 0 }
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    if llmChatHistoryScroll > maxScroll { llmChatHistoryScroll = maxScroll }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    tableSet(llmChat, "history_page_size", historyRows)

    let historyBody = stringRenderViewport(historyContent, columns, historyRows, -1 * (llmChatHistoryScroll + 1))
    let provider = tableGet(llmChat, "provider")
    let modelName = "unknown"
    if provider != null { modelName = tableGet(provider, "model") }
    let status = "Model: " + modelName + " | Pending tools: " + toString(arrayLen(pendingToolCalls))

    let content = "ðŸ¤– LLM Chat\n" + status + "\nenter: send | y/n: allow/deny tool | up/down: scroll\n"
    content = content + "â•­â”€ History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    if showEllipsis { content = content + "   â‹¯\n" }
    content = content + historyBody + "\n"
    content = content + "â•°â”€ Pending Tools â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(pendingLines) + "\n"
    content = content + "â•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(inputLines)

    setViewportBufferContent(tableGet(llmChat, "id"), content)
}

fn requestChatCompletion() {
    let provider = tableGet(llmChat, "provider")
    if provider == null { return null }

    let apiKey = tableGet(provider, "api_key")
    let modelName = tableGet(provider, "model")
    let url = tableGet(provider, "url")

    let request = createTable()
    tableSet(request, "model", modelName)
    tableSet(request, "messages", tableGet(llmChat, "history"))
    tableSet(request, "tools", fromJson(toolDeclarations()))
    tableSet(request, "stream", false)
    tableSet(request, "temperature", 0.3)
    tableSet(request, "seed", 42)

    let body = toJson(request)
    let hasApiKey = apiKey != null and stringLen(apiKey) != 0
    let response = null
    if hasApiKey { response = postRequestWithBearerToken(url, body, apiKey) }
    if !hasApiKey { response = postRequest(url, body) }
    response = fromJson(response)
    let message = tableGet(arrayGet(tableGet(response, "choices"), 0), "message")
    let toolCalls = tableGet(message, "tool_calls")
    
    if toolCalls != null {
        let pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
        let i = arrayLen(toolCalls)
        loop {
            if i <= 0 { break }
            let toolCall = arrayGet(toolCalls, i - 1)
            
            arrayPushBack(pendingToolCalls, toolCall)
            
            let toolName = tableGet(tableGet(toolCall, "function"), "name")
            let toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
            let toolCallId = tableGet(toolCall, "id")
            
            i = i - 1
        }
    }
    
    arrayPushBack(tableGet(llmChat, "history"), message)

    renderLLMChat()
}

fn getToolCallResult(allowed) {
    let pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    let toolCall = arrayPopBack(pendingToolCalls)
    
    let toolName = tableGet(tableGet(toolCall, "function"), "name")
    let toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
    let toolCallId = tableGet(toolCall, "id")
    
    let result = "Tool call request denied by user. Await further instructions."
    
    if allowed {
        if toolName == "run_shell_command" {
            result = agentRunShellCommand(tableGet(toolArgs, "command"))
        }
        if toolName == "find_file" {
            result = agentFindFile(tableGet(toolArgs, "pattern"))
        }
        if toolName == "search_workspace" {
            result = agentSearchWorkspace(tableGet(toolArgs, "pattern"))
        }
        if toolName == "read_file" {
            result = agentReadFile(getWorkspaceDir(), tableGet(toolArgs, "path"))
        }
        if toolName == "write_file" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "content"))
        }
        if toolName == "replace" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "old_string"), tableGet(toolArgs, "new_string"))
        }
    }
    
    let message = createTable()
    tableSet(message, "role", "tool")
    tableSet(message, "content", result)
    tableSet(message, "name", toolName)
    tableSet(message, "tool_call_id", toolCallId)
    arrayPushBack(tableGet(llmChat, "history"), message)
    
    renderLLMChat()

    if arrayLen(pendingToolCalls) == 0 {
        requestChatCompletion()
    }
}

fn allowToolCall() { getToolCallResult(true) }
fn denyToolCall() { getToolCallResult(false) }

fn sendMessage() {
    let pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    if arrayLen(pendingToolCalls) == 0 {
        let message = createTable()
        tableSet(message, "role", "user")
        tableSet(message, "content", tableGet(llmChat, "input"))
        arrayPushBack(tableGet(llmChat, "history"), message)

        llmChatClearInput()
        renderLLMChat()
    
        requestChatCompletion()
    }
}

fn llmChatInputUpdated() {
    inputUpdated(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatAddSpace() {
    inputAddSpace(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatBackspace() {
    inputBackspace(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatClearInput() {
    inputClear(tableGet(llmChat, "id"), llmChat, "input", null)
}

fn createLLMChat() {
    if tableGet(llmChat, "id") == -1 {
        let bufferId = createSpecialBuffer("LLM Chat")
        tableSet(llmChat, "id", bufferId)
        registerBufferKeybind(bufferId, "ins enter", sendMessage)
        registerBufferKeybind(bufferId, "nor up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "nor down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "nor pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "nor pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "ins space", llmChatAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", llmChatBackspace)
        registerBufferKeybind(bufferId, "ins up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "ins down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "nor y", allowToolCall)
        registerBufferKeybind(bufferId, "nor n", denyToolCall)
        registerBufferInputHook(bufferId, llmChatInputUpdated)
        renderLLMChat()
    }
    setActiveBuffer(tableGet(llmChat, "id"))
}

registerGlobalKeybind("nor space c", createLLMChat)

############

# Fuzzy Find File

fn fuzzyFileFinderDependenciesAvailable() {
    return commandExists("fd") and commandExists("fzf")
}

fn fuzzyFileFinderDependenciesError() {
    infoModalOpen("Fuzzy File Finder requires `fd` and `fzf` to be installed and available in PATH.")
}

let fuzzyFileFinder = createTable()
tableSet(fuzzyFileFinder, "id", -1)
tableSet(fuzzyFileFinder, "input", "")
tableSet(fuzzyFileFinder, "results", createArray())
tableSet(fuzzyFileFinder, "selected", 0)
tableSet(fuzzyFileFinder, "previous_buffer_id", -1)

fn renderFuzzyFileFinder() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ”Ž Fuzzy File Finder")
    tableSet(ctx, "input_header", "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(fuzzyFileFinder, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(fuzzyFileFinder, "results"))
    tableSet(ctx, "selected_index", tableGet(fuzzyFileFinder, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No files found")
    tableSet(ctx, "buffer_id", tableGet(fuzzyFileFinder, "id"))
    listPanelRender(ctx)
}

fn fuzzyFileFinderWorkspaceEntries() {
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path", getWorkspaceDir())
    tableSet(fuzzyFileFinder, "results", stringSplitLines(tableGet(results, "stdout")))
    tableSet(fuzzyFileFinder, "selected", 0)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderInputUpdated() {
    inputUpdated(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path | fzf -f \"" + tableGet(fuzzyFileFinder, "input") + "\"", getWorkspaceDir())
    tableSet(fuzzyFileFinder, "results", stringSplitLines(tableGet(results, "stdout")))
    tableSet(fuzzyFileFinder, "selected", 0)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderAddSpace() {
    inputAddSpace(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", renderFuzzyFileFinder)
}

fn fuzzyFileFinderBackspace() {
    inputBackspace(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderClearInput() {
    inputClear(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderMoveSelection(delta) {
    let results = tableGet(fuzzyFileFinder, "results")
    let selected = listPanelMoveSelection(results, tableGet(fuzzyFileFinder, "selected"), delta)
    tableSet(fuzzyFileFinder, "selected", selected)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderNext() {
    fuzzyFileFinderMoveSelection(1)
}

fn fuzzyFileFinderPrevious() {
    fuzzyFileFinderMoveSelection(-1)
}

fn fuzzyFileFinderSelect() {
    let results = tableGet(fuzzyFileFinder, "results")
    let selected = tableGet(fuzzyFileFinder, "selected")
    if selected < arrayLen(results) {
        let path = arrayGet(results, selected)
        fuzzyFileFinderClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fuzzyFileFinderEscape() {
    let previousBufferId = tableGet(fuzzyFileFinder, "previous_buffer_id")
    if previousBufferId != -1 {
        fuzzyFileFinderClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createFuzzyFileFinder() {
    if !fuzzyFileFinderDependenciesAvailable() {
        fuzzyFileFinderDependenciesError()
        return null
    }
    tableSet(fuzzyFileFinder, "previous_buffer_id", getActiveBuffer())
    if tableGet(fuzzyFileFinder, "id") == -1 {
        let bufferId = createSpecialBuffer("Fuzzy File Finder")
        tableSet(fuzzyFileFinder, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", fuzzyFileFinderAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fuzzyFileFinderBackspace)
        registerBufferKeybind(bufferId, "ins tab", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins down", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins up", fuzzyFileFinderPrevious)
        registerBufferKeybind(bufferId, "ins enter", fuzzyFileFinderSelect)
        registerBufferKeybind(bufferId, "ins escape", fuzzyFileFinderEscape)
        registerBufferInputHook(bufferId, fuzzyFileFinderInputUpdated)
    }
    fuzzyFileFinderClearInput()
    setActiveBuffer(tableGet(fuzzyFileFinder, "id"))
    fuzzyFileFinderWorkspaceEntries()
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space f", createFuzzyFileFinder)

############

# File Explorer

let fileExplorer = createTable()
tableSet(fileExplorer, "id", -1)
tableSet(fileExplorer, "input", "")
tableSet(fileExplorer, "entries", createArray())
tableSet(fileExplorer, "all_entries", createArray())
tableSet(fileExplorer, "selected", 0)
tableSet(fileExplorer, "current_dir", "")
tableSet(fileExplorer, "previous_buffer_id", -1)
tableSet(fileExplorer, "error", "")

fn fileExplorerEntryDisplay(entry) {
    let name = tableGet(entry, "name")
    if tableGet(entry, "is_dir") {
        return name + "/"
    }
    return name
}

fn renderFileExplorer() {
    let headerLines = createArray()
    arrayPushBack(headerLines, tableGet(fileExplorer, "current_dir"))
    arrayPushBack(headerLines, "(ctrl-f: new file, ctrl-d: new folder)")

    let extraLines = null
    let errorMessage = tableGet(fileExplorer, "error")
    if errorMessage != "" {
        extraLines = createArray()
        arrayPushBack(extraLines, "   Error: " + errorMessage)
    }

    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ“‚ File Explorer")
    tableSet(ctx, "header_lines", headerLines)
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(fileExplorer, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Entries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(fileExplorer, "entries"))
    tableSet(ctx, "selected_index", tableGet(fileExplorer, "selected"))
    tableSet(ctx, "reserved_lines", 6)
    tableSet(ctx, "empty_text", "No entries")
    tableSet(ctx, "buffer_id", tableGet(fileExplorer, "id"))
    tableSet(ctx, "entry_to_string", fileExplorerEntryDisplay)
    tableSet(ctx, "extra_lines", extraLines)
    listPanelRender(ctx)
}

fn fileExplorerApplyFilter() {
    let query = stringToLower(tableGet(fileExplorer, "input"))
    let entries = createArray()
    let allEntries = tableGet(fileExplorer, "all_entries")

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = arrayGet(allEntries, i)
        let name = stringToLower(tableGet(entry, "name"))

        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(entries, entry)
        }

        i = i + 1
    }

    tableSet(fileExplorer, "entries", entries)

    if arrayLen(entries) == 0 {
        tableSet(fileExplorer, "selected", 0)
    }
    if tableGet(fileExplorer, "selected") >= arrayLen(entries) {
        tableSet(fileExplorer, "selected", 0)
    }

    renderFileExplorer()
}

fn fileExplorerRefreshEntries() {
    let listing = listDir(tableGet(fileExplorer, "current_dir"))
    let allEntries = createArray()
    tableSet(fileExplorer, "error", "")

    let errorMessage = tableGet(listing, "error")
    if errorMessage != null {
        tableSet(fileExplorer, "error", errorMessage)
    }

    let entries = tableGet(listing, "entries")

    let parentEntry = createTable()
    tableSet(parentEntry, "name", "..")
    tableSet(parentEntry, "path", parentPath(tableGet(fileExplorer, "current_dir")))
    tableSet(parentEntry, "is_dir", true)
    arrayPushBack(allEntries, parentEntry)

    let i = 0
    loop {
        if i >= arrayLen(entries) { break }
        let entry = arrayGet(entries, i)
        arrayPushBack(allEntries, entry)
        i = i + 1
    }

    tableSet(fileExplorer, "all_entries", allEntries)
    tableSet(fileExplorer, "selected", 0)
    fileExplorerApplyFilter()
}

fn fileExplorerSetDirectory(path) {
    tableSet(fileExplorer, "current_dir", path)
    fileExplorerRefreshEntries()
}

fn fileExplorerInputUpdated() {
    inputUpdated(tableGet(fileExplorer, "id"), fileExplorer, "input", fileExplorerApplyFilter)
}

fn fileExplorerAddSpace() {
    inputAddSpace(tableGet(fileExplorer, "id"), fileExplorer, "input", renderFileExplorer)
}

fn fileExplorerBackspace() {
    inputBackspace(tableGet(fileExplorer, "id"), fileExplorer, "input", null)
}

fn fileExplorerClearInput() {
    inputClear(tableGet(fileExplorer, "id"), fileExplorer, "input", null)
}

fn fileExplorerMoveSelection(delta) {
    let entries = tableGet(fileExplorer, "entries")
    let selected = listPanelMoveSelection(entries, tableGet(fileExplorer, "selected"), delta)
    tableSet(fileExplorer, "selected", selected)
    renderFileExplorer()
}

fn fileExplorerNext() {
    fileExplorerMoveSelection(1)
}

fn fileExplorerPrevious() {
    fileExplorerMoveSelection(-1)
}

fn fileExplorerSelect() {
    let entries = tableGet(fileExplorer, "entries")
    let selected = tableGet(fileExplorer, "selected")
    if selected < arrayLen(entries) {
        let entry = arrayGet(entries, selected)
        let path = tableGet(entry, "path")
        if tableGet(entry, "is_dir") {
            fileExplorerClearInput()
            fileExplorerSetDirectory(path)
            return null
        }
        fileExplorerClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerEscape() {
    let previousBufferId = tableGet(fileExplorer, "previous_buffer_id")
    if previousBufferId != -1 {
        fileExplorerClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerCreateFileSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("File name cannot be empty.")
        return null
    }

    let targetPath = joinPath(tableGet(fileExplorer, "current_dir"), pathInput)
    let result = createBlankFile(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerRefreshEntries()
    openFile(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFilePrompt() {
    let prompt = "Create File\n" + tableGet(fileExplorer, "current_dir") + "\nEnter file name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFileSubmit)
}

fn fileExplorerCreateFolderSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("Folder name cannot be empty.")
        return null
    }

    let targetPath = joinPath(tableGet(fileExplorer, "current_dir"), pathInput)
    let result = createDirectory(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerSetDirectory(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFolderPrompt() {
    let prompt = "Create Folder\n" + tableGet(fileExplorer, "current_dir") + "\nEnter folder name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFolderSubmit)
}

fn createFileExplorer() {
    tableSet(fileExplorer, "previous_buffer_id", getActiveBuffer())

    if tableGet(fileExplorer, "id") == -1 {
        let bufferId = createSpecialBuffer("File Explorer")
        tableSet(fileExplorer, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", fileExplorerAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fileExplorerBackspace)
        registerBufferKeybind(bufferId, "ins tab", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins down", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins up", fileExplorerPrevious)
        registerBufferKeybind(bufferId, "ins enter", fileExplorerSelect)
        registerBufferKeybind(bufferId, "ins escape", fileExplorerEscape)
        registerBufferKeybind(bufferId, "ins c-f", fileExplorerCreateFilePrompt)
        registerBufferKeybind(bufferId, "ins c-d", fileExplorerCreateFolderPrompt)
        registerBufferInputHook(bufferId, fileExplorerInputUpdated)
    }

    fileExplorerClearInput()
    fileExplorerSetDirectory(getWorkspaceDir())
    setActiveBuffer(tableGet(fileExplorer, "id"))
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space s-f", createFileExplorer)

############

# Switch Buffer

let switchBuffer = createTable()
tableSet(switchBuffer, "id", -1)
tableSet(switchBuffer, "input", "")
tableSet(switchBuffer, "results", createArray())
tableSet(switchBuffer, "buffers", createArray())
tableSet(switchBuffer, "selected", 0)
tableSet(switchBuffer, "selected_id", -1)
tableSet(switchBuffer, "previous_buffer_id", -1)
tableSet(switchBuffer, "initial_active_id", -1)

fn switchBufferDisplay(entry) {
    let display = tableGet(entry, "display_name")
    if tableGet(entry, "special") {
        display = "[special] " + display
    }
    if tableGet(entry, "modified") {
        display = display + " *"
    }
    if tableGet(entry, "is_active") {
        display = display + " (active)"
    }
    return display
}

fn renderSwitchBuffer() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ—‚ Switch Buffer")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(switchBuffer, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Buffers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(switchBuffer, "results"))
    tableSet(ctx, "selected_index", tableGet(switchBuffer, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No buffers")
    tableSet(ctx, "buffer_id", tableGet(switchBuffer, "id"))
    tableSet(ctx, "entry_to_string", switchBufferDisplay)
    listPanelRender(ctx)
}

fn switchBufferLoadBuffers() {
    let buffers = listBuffers()
    tableSet(switchBuffer, "buffers", fromJson(buffers))
}

fn switchBufferUpdateSelectionFromId(targetId) {
    let results = tableGet(switchBuffer, "results")
    if arrayLen(results) == 0 {
        tableSet(switchBuffer, "selected", 0)
        tableSet(switchBuffer, "selected_id", -1)
        renderSwitchBuffer()
        return null
    }

    let selectedEntry = 0
    let i = 0
    loop {
        if i >= arrayLen(results) { break }
        let entry = arrayGet(results, i)
        if tableGet(entry, "id") == targetId {
            selectedEntry = i
            break
        }
        i = i + 1
    }

    let selectedEntryValue = arrayGet(results, selectedEntry)
    tableSet(switchBuffer, "selected", selectedEntry)
    tableSet(switchBuffer, "selected_id", tableGet(selectedEntryValue, "id"))
    renderSwitchBuffer()
}

fn switchBufferUpdateResults() {
    switchBufferLoadBuffers()

    let previousSelectionId = tableGet(switchBuffer, "selected_id")
    if previousSelectionId == -1 {
        previousSelectionId = tableGet(switchBuffer, "initial_active_id")
    }

    let query = stringToLower(tableGet(switchBuffer, "input"))
    let results = createArray()
    let buffers = tableGet(switchBuffer, "buffers")

    let i = 0
    loop {
        if i >= arrayLen(buffers) { break }
        let entry = arrayGet(buffers, i)
        let name = stringToLower(tableGet(entry, "display_name"))
        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(switchBuffer, "results", results)
    tableSet(switchBuffer, "selected_id", -1)
    tableSet(switchBuffer, "selected", 0)
    switchBufferUpdateSelectionFromId(previousSelectionId)
}

fn switchBufferInputUpdated() {
    inputUpdated(tableGet(switchBuffer, "id"), switchBuffer, "input", switchBufferUpdateResults)
}

fn switchBufferAddSpace() {
    inputAddSpace(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferBackspace() {
    inputBackspace(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferClearInput() {
    inputClear(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferMoveSelection(delta) {
    let results = tableGet(switchBuffer, "results")
    let selected = listPanelMoveSelection(results, tableGet(switchBuffer, "selected"), delta)
    tableSet(switchBuffer, "selected", selected)
    if arrayLen(results) == 0 {
        tableSet(switchBuffer, "selected_id", -1)
    }
    if arrayLen(results) != 0 {
        let entry = arrayGet(results, selected)
        tableSet(switchBuffer, "selected_id", tableGet(entry, "id"))
    }
    renderSwitchBuffer()
}

fn switchBufferNext() {
    switchBufferMoveSelection(1)
}

fn switchBufferPrevious() {
    switchBufferMoveSelection(-1)
}

fn switchBufferSelect() {
    let results = tableGet(switchBuffer, "results")
    let selected = tableGet(switchBuffer, "selected")
    if selected < arrayLen(results) {
        let selection = arrayGet(results, selected)
        let bufferId = tableGet(selection, "id")
        switchBufferClearInput()
        setActiveBuffer(bufferId)
        runAction("quit-insert-mode")
    }
}

fn switchBufferEscape() {
    let previousBufferId = tableGet(switchBuffer, "previous_buffer_id")
    if previousBufferId != -1 {
        switchBufferClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createSwitchBuffer() {
    let previousBufferId = getActiveBuffer()
    tableSet(switchBuffer, "previous_buffer_id", previousBufferId)
    tableSet(switchBuffer, "initial_active_id", previousBufferId)
    tableSet(switchBuffer, "selected_id", -1)

    if tableGet(switchBuffer, "id") == -1 {
        let bufferId = createSpecialBuffer("Switch Buffer")
        tableSet(switchBuffer, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", switchBufferAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", switchBufferBackspace)
        registerBufferKeybind(bufferId, "ins tab", switchBufferNext)
        registerBufferKeybind(bufferId, "ins down", switchBufferNext)
        registerBufferKeybind(bufferId, "ins up", switchBufferPrevious)
        registerBufferKeybind(bufferId, "ins enter", switchBufferSelect)
        registerBufferKeybind(bufferId, "ins escape", switchBufferEscape)
        registerBufferInputHook(bufferId, switchBufferInputUpdated)
    }

    switchBufferClearInput()
    switchBufferUpdateResults()
    setActiveBuffer(tableGet(switchBuffer, "id"))
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space b", createSwitchBuffer)

############

# Workspace Search

fn workspaceSearchDependenciesAvailable() {
    return commandExists("rg")
}

fn workspaceSearchDependenciesError() {
    infoModalOpen("Workspace Search requires `rg` (ripgrep) to be installed and available in PATH.")
}

let workspaceSearch = createTable()
tableSet(workspaceSearch, "id", -1)
tableSet(workspaceSearch, "input", "")
tableSet(workspaceSearch, "results", createArray())
tableSet(workspaceSearch, "selected", 0)
tableSet(workspaceSearch, "previous_buffer_id", -1)

fn workspaceSearchDisplay(entry) {
    return tableGet(entry, "display")
}

fn renderWorkspaceSearch() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ” Workspace Search")
    tableSet(ctx, "input_header", "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(workspaceSearch, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(workspaceSearch, "results"))
    tableSet(ctx, "selected_index", tableGet(workspaceSearch, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No matches")
    tableSet(ctx, "buffer_id", tableGet(workspaceSearch, "id"))
    tableSet(ctx, "entry_to_string", workspaceSearchDisplay)
    listPanelRender(ctx)
}

fn workspaceSearchClearInput() {
    inputClear(tableGet(workspaceSearch, "id"), workspaceSearch, "input", null)
}

fn workspaceSearchBackspace() {
    inputBackspace(tableGet(workspaceSearch, "id"), workspaceSearch, "input", null)
}

fn workspaceSearchUpdateResults() {
    tableSet(workspaceSearch, "results", createArray())
    if stringLen(tableGet(workspaceSearch, "input")) <= 1 {
        tableSet(workspaceSearch, "selected", 0)
        renderWorkspaceSearch()
        return null
    }

    let results = runShellCommand("rg --json --color=never --smart-case --max-count 100 \"" + tableGet(workspaceSearch, "input") + "\"", getWorkspaceDir())
    let lines = stringSplitLines(tableGet(results, "stdout"))
    let entries = createArray()

    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = arrayGet(lines, i)
        if line != "" {
            let rgResult = fromJson(line)
            if tableGet(rgResult, "type") == "match" {
                let data = tableGet(rgResult, "data")
                let filePath = tableGet(tableGet(data, "path"), "text")
                let row = tableGet(data, "line_number") - 1
                let lineText = tableGet(tableGet(data, "lines"), "text")
                let lineParts = stringSplitLines(lineText)
                if arrayLen(lineParts) > 0 {
                    lineText = arrayGet(lineParts, 0)
                }
                let submatches = tableGet(data, "submatches")
                let j = 0
                loop {
                    if j >= arrayLen(submatches) { break }
                    let submatch = arrayGet(submatches, j)
                    let start = tableGet(submatch, "start")
                    let end = tableGet(submatch, "end")

                    let display = filePath + ":" + toJson(row) + ":" + toJson(start) + " " + lineText

                    let entry = createTable()
                    tableSet(entry, "file_path", filePath)
                    tableSet(entry, "row", row)
                    tableSet(entry, "start", start)
                    tableSet(entry, "end", end)
                    tableSet(entry, "display", display)
                    arrayPushBack(entries, entry)
                    j = j + 1
                }
            }
        }
        i = i + 1
    }
    tableSet(workspaceSearch, "results", entries)
    tableSet(workspaceSearch, "selected", 0)
    renderWorkspaceSearch()
}

fn workspaceSearchInputUpdated() {
    inputUpdated(tableGet(workspaceSearch, "id"), workspaceSearch, "input", workspaceSearchUpdateResults)
}

fn workspaceSearchAddSpace() {
    inputAddSpace(tableGet(workspaceSearch, "id"), workspaceSearch, "input", renderWorkspaceSearch)
}

fn workspaceSearchMoveSelection(delta) {
    let results = tableGet(workspaceSearch, "results")
    let selected = listPanelMoveSelection(results, tableGet(workspaceSearch, "selected"), delta)
    tableSet(workspaceSearch, "selected", selected)
    renderWorkspaceSearch()
}

fn workspaceSearchNext() {
    workspaceSearchMoveSelection(1)
}

fn workspaceSearchPrevious() {
    workspaceSearchMoveSelection(-1)
}

fn workspaceSearchSelect() {
    let results = tableGet(workspaceSearch, "results")
    let selected = tableGet(workspaceSearch, "selected")
    if selected < arrayLen(results) {
        let selection = arrayGet(results, selected)
        let path = tableGet(selection, "file_path")
        let row = tableGet(selection, "row")
        let start = tableGet(selection, "start")
        let end = tableGet(selection, "end")

        let range = createTable()
        let cursor = createTable()
        let mark = createTable()

        tableSet(mark, "row", row)
        tableSet(mark, "column", start)
        tableSet(cursor, "row", row)
        tableSet(cursor, "column", end)
        tableSet(range, "cursor", cursor)
        tableSet(range, "mark", mark)

        workspaceSearchClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceSearchEscape() {
    let previousBufferId = tableGet(workspaceSearch, "previous_buffer_id")
    if previousBufferId != -1 {
        workspaceSearchClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createWorkspaceSearch() {
    if !workspaceSearchDependenciesAvailable() {
        workspaceSearchDependenciesError()
        return null
    }
    tableSet(workspaceSearch, "previous_buffer_id", getActiveBuffer())
    if tableGet(workspaceSearch, "id") == -1 {
        let bufferId = createSpecialBuffer("Workspace Search")
        tableSet(workspaceSearch, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", workspaceSearchAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceSearchBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins down", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins up", workspaceSearchPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceSearchSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceSearchEscape)
        registerBufferInputHook(bufferId, workspaceSearchInputUpdated)
    }
    workspaceSearchClearInput()
    setActiveBuffer(tableGet(workspaceSearch, "id"))
    workspaceSearchUpdateResults()
    runAction("enter-insert-mode")
}

############

# Workspace Diagnostics

let workspaceDiagnostics = createTable()
tableSet(workspaceDiagnostics, "id", -1)
tableSet(workspaceDiagnostics, "input", "")
tableSet(workspaceDiagnostics, "all", createArray())
tableSet(workspaceDiagnostics, "results", createArray())
tableSet(workspaceDiagnostics, "selected", 0)
tableSet(workspaceDiagnostics, "previous_buffer_id", -1)

fn workspaceDiagnosticsDisplay(entry) {
    let filePath = tableGet(entry, "file_path")
    let range = tableGet(entry, "range")
    let mark = tableGet(range, "mark")
    let row = tableGet(mark, "row") + 1
    let column = tableGet(mark, "column") + 1
    let severity = tableGet(entry, "severity")
    let source = tableGet(entry, "source")
    let code = tableGet(entry, "code")
    let message = tableGet(entry, "message")

    if source == "null" { source = "" }
    if code == "null" { code = "" }

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    let details = source
    if stringLen(code) > 0 {
        details = details + " " + code
    }

    if stringLen(details) > 0 {
        return "[" + severity + "] " + location + " (" + details + ") " + message
    }

    return "[" + severity + "] " + location + " " + message
}

fn renderWorkspaceDiagnostics() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ©º Diagnostics")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(workspaceDiagnostics, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(workspaceDiagnostics, "results"))
    tableSet(ctx, "selected_index", tableGet(workspaceDiagnostics, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No diagnostics")
    tableSet(ctx, "buffer_id", tableGet(workspaceDiagnostics, "id"))
    tableSet(ctx, "entry_to_string", workspaceDiagnosticsDisplay)
    listPanelRender(ctx)
}

fn workspaceDiagnosticsFilterResults() {
    let results = createArray()
    let query = stringToLower(tableGet(workspaceDiagnostics, "input"))
    let allEntries = tableGet(workspaceDiagnostics, "all")

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = arrayGet(allEntries, i)

        let message = stringToLower(tableGet(entry, "message"))
        let filePath = stringToLower(tableGet(entry, "file_path"))
        let severity = stringToLower(tableGet(entry, "severity"))
        let source = stringToLower(tableGet(entry, "source"))

        if stringLen(query) == 0 or stringContains(message, query) or stringContains(filePath, query) or stringContains(severity, query) or stringContains(source, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(workspaceDiagnostics, "results", results)
    tableSet(workspaceDiagnostics, "selected", 0)
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsInputUpdated() {
    inputUpdated(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", workspaceDiagnosticsFilterResults)
}

fn workspaceDiagnosticsAddSpace() {
    inputAddSpace(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", renderWorkspaceDiagnostics)
}

fn workspaceDiagnosticsBackspace() {
    inputBackspace(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsClearInput() {
    inputClear(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsMoveSelection(delta) {
    let results = tableGet(workspaceDiagnostics, "results")
    let selected = listPanelMoveSelection(results, tableGet(workspaceDiagnostics, "selected"), delta)
    tableSet(workspaceDiagnostics, "selected", selected)
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsNext() {
    workspaceDiagnosticsMoveSelection(1)
}

fn workspaceDiagnosticsPrevious() {
    workspaceDiagnosticsMoveSelection(-1)
}

fn workspaceDiagnosticsSelect() {
    let results = tableGet(workspaceDiagnostics, "results")
    let selected = tableGet(workspaceDiagnostics, "selected")
    if selected < arrayLen(results) {
        let entry = arrayGet(results, selected)
        let path = tableGet(entry, "file_path")
        let range = tableGet(entry, "range")

        workspaceDiagnosticsClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceDiagnosticsEscape() {
    let previousBufferId = tableGet(workspaceDiagnostics, "previous_buffer_id")
    if previousBufferId != -1 {
        workspaceDiagnosticsClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn workspaceDiagnosticsReload() {
    let diagnostics = getWorkspaceDiagnostics()
    tableSet(workspaceDiagnostics, "all", fromJson(diagnostics))
    workspaceDiagnosticsFilterResults()
}

fn createWorkspaceDiagnostics() {
    tableSet(workspaceDiagnostics, "previous_buffer_id", getActiveBuffer())
    if tableGet(workspaceDiagnostics, "id") == -1 {
        let bufferId = createSpecialBuffer("Workspace Diagnostics")
        tableSet(workspaceDiagnostics, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", workspaceDiagnosticsAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceDiagnosticsBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins down", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins up", workspaceDiagnosticsPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceDiagnosticsSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceDiagnosticsEscape)
        registerBufferInputHook(bufferId, workspaceDiagnosticsInputUpdated)
    }
    workspaceDiagnosticsClearInput()
    workspaceDiagnosticsReload()
    setActiveBuffer(tableGet(workspaceDiagnostics, "id"))
    runAction("enter-insert-mode")
}

############

# Command Dispatcher

let commandDispatcher = createTable()
tableSet(commandDispatcher, "id", -1)
tableSet(commandDispatcher, "input", "")
tableSet(commandDispatcher, "all", createArray())
tableSet(commandDispatcher, "results", createArray())
tableSet(commandDispatcher, "selected", 0)
tableSet(commandDispatcher, "previous_buffer_id", -1)

fn renderCommandDispatcher() {
    let ctx = createTable()
    tableSet(ctx, "title", "âš¡ Command Palette")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(commandDispatcher, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(commandDispatcher, "results"))
    tableSet(ctx, "selected_index", tableGet(commandDispatcher, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No commands")
    tableSet(ctx, "buffer_id", tableGet(commandDispatcher, "id"))
    listPanelRender(ctx)
}

fn commandDispatcherFilterResults() {
    let results = createArray()
    let query = stringToLower(tableGet(commandDispatcher, "input"))
    let allActions = tableGet(commandDispatcher, "all")

    let i = 0
    loop {
        if i >= arrayLen(allActions) { break }
        let action = arrayGet(allActions, i)
        let actionLower = stringToLower(action)

        if stringLen(query) == 0 or stringContains(actionLower, query) {
            arrayPushBack(results, action)
        }
        i = i + 1
    }

    tableSet(commandDispatcher, "results", results)
    tableSet(commandDispatcher, "selected", 0)
    renderCommandDispatcher()
}

fn commandDispatcherInputUpdated() {
    inputUpdated(tableGet(commandDispatcher, "id"), commandDispatcher, "input", commandDispatcherFilterResults)
}

fn commandDispatcherAddSpace() {
    inputAddSpace(tableGet(commandDispatcher, "id"), commandDispatcher, "input", renderCommandDispatcher)
}

fn commandDispatcherBackspace() {
    inputBackspace(tableGet(commandDispatcher, "id"), commandDispatcher, "input", null)
}

fn commandDispatcherClearInput() {
    inputClear(tableGet(commandDispatcher, "id"), commandDispatcher, "input", null)
}

fn commandDispatcherMoveSelection(delta) {
    let results = tableGet(commandDispatcher, "results")
    let selected = listPanelMoveSelection(results, tableGet(commandDispatcher, "selected"), delta)
    tableSet(commandDispatcher, "selected", selected)
    renderCommandDispatcher()
}

fn commandDispatcherNext() {
    commandDispatcherMoveSelection(1)
}

fn commandDispatcherPrevious() {
    commandDispatcherMoveSelection(-1)
}

fn commandDispatcherSelect() {
    let results = tableGet(commandDispatcher, "results")
    let selected = tableGet(commandDispatcher, "selected")
    if selected < arrayLen(results) {
        let action = arrayGet(results, selected)
        let previousBufferId = tableGet(commandDispatcher, "previous_buffer_id")
        commandDispatcherClearInput()
        if previousBufferId != -1 {
            setActiveBuffer(previousBufferId)
        }
        runAction("quit-insert-mode")
        runAction(action)
    }
}

fn commandDispatcherEscape() {
    let previousBufferId = tableGet(commandDispatcher, "previous_buffer_id")
    if previousBufferId != -1 {
        commandDispatcherClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn commandDispatcherReload() {
    let actions = getActions()
    tableSet(commandDispatcher, "all", fromJson(actions))
    commandDispatcherFilterResults()
}

fn createCommandDispatcher() {
    tableSet(commandDispatcher, "previous_buffer_id", getActiveBuffer())
    if tableGet(commandDispatcher, "id") == -1 {
        let bufferId = createSpecialBuffer("Command Dispatcher")
        tableSet(commandDispatcher, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", commandDispatcherAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", commandDispatcherBackspace)
        registerBufferKeybind(bufferId, "ins tab", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins down", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins up", commandDispatcherPrevious)
        registerBufferKeybind(bufferId, "ins enter", commandDispatcherSelect)
        registerBufferKeybind(bufferId, "ins escape", commandDispatcherEscape)
        registerBufferInputHook(bufferId, commandDispatcherInputUpdated)
    }
    commandDispatcherClearInput()
    commandDispatcherReload()
    setActiveBuffer(tableGet(commandDispatcher, "id"))
    runAction("enter-insert-mode")
}

############

# Go To Definition

let goToDefinition = createTable()
tableSet(goToDefinition, "id", -1)
tableSet(goToDefinition, "input", "")
tableSet(goToDefinition, "all", createArray())
tableSet(goToDefinition, "results", createArray())
tableSet(goToDefinition, "selected", 0)
tableSet(goToDefinition, "previous_buffer_id", -1)

fn goToDefinitionDisplay(entry) {
    let filePath = tableGet(entry, "file_path")
    let range = tableGet(entry, "range")
    let mark = tableGet(range, "mark")
    let row = tableGet(mark, "row") + 1
    let column = tableGet(mark, "column") + 1
    let preview = tableGet(entry, "preview")

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToDefinition() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ“Œ Definitions")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(goToDefinition, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(goToDefinition, "results"))
    tableSet(ctx, "selected_index", tableGet(goToDefinition, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No definitions")
    tableSet(ctx, "buffer_id", tableGet(goToDefinition, "id"))
    tableSet(ctx, "entry_to_string", goToDefinitionDisplay)
    listPanelRender(ctx)
}

fn goToDefinitionFilterResults() {
    let results = createArray()
    let query = stringToLower(tableGet(goToDefinition, "input"))
    let allEntries = tableGet(goToDefinition, "all")

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = arrayGet(allEntries, i)

        let filePath = stringToLower(tableGet(entry, "file_path"))
        let preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(goToDefinition, "results", results)
    tableSet(goToDefinition, "selected", 0)
    renderGoToDefinition()
}

fn goToDefinitionInputUpdated() {
    inputUpdated(tableGet(goToDefinition, "id"), goToDefinition, "input", goToDefinitionFilterResults)
}

fn goToDefinitionAddSpace() {
    inputAddSpace(tableGet(goToDefinition, "id"), goToDefinition, "input", renderGoToDefinition)
}

fn goToDefinitionBackspace() {
    inputBackspace(tableGet(goToDefinition, "id"), goToDefinition, "input", null)
}

fn goToDefinitionClearInput() {
    inputClear(tableGet(goToDefinition, "id"), goToDefinition, "input", null)
}

fn goToDefinitionMoveSelection(delta) {
    let results = tableGet(goToDefinition, "results")
    let selected = listPanelMoveSelection(results, tableGet(goToDefinition, "selected"), delta)
    tableSet(goToDefinition, "selected", selected)
    renderGoToDefinition()
}

fn goToDefinitionNext() {
    goToDefinitionMoveSelection(1)
}

fn goToDefinitionPrevious() {
    goToDefinitionMoveSelection(-1)
}

fn goToDefinitionSelect() {
    let results = tableGet(goToDefinition, "results")
    let selected = tableGet(goToDefinition, "selected")
    if selected < arrayLen(results) {
        let entry = arrayGet(results, selected)
        let path = tableGet(entry, "file_path")
        let range = tableGet(entry, "range")

        goToDefinitionClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToDefinitionEscape() {
    let previousBufferId = tableGet(goToDefinition, "previous_buffer_id")
    if previousBufferId != -1 {
        goToDefinitionClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToDefinitionReload() {
    let definitions = getDefinitions()
    tableSet(goToDefinition, "all", fromJson(definitions))
    goToDefinitionFilterResults()
}

fn createGoToDefinition() {
    tableSet(goToDefinition, "previous_buffer_id", getActiveBuffer())
    if tableGet(goToDefinition, "id") == -1 {
        let bufferId = createSpecialBuffer("Definitions")
        tableSet(goToDefinition, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", goToDefinitionAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToDefinitionBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins down", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins up", goToDefinitionPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToDefinitionSelect)
        registerBufferKeybind(bufferId, "ins escape", goToDefinitionEscape)
        registerBufferInputHook(bufferId, goToDefinitionInputUpdated)
    }
    goToDefinitionClearInput()
    goToDefinitionReload()
    setActiveBuffer(tableGet(goToDefinition, "id"))
    runAction("enter-insert-mode")
}

# Go To References

let goToReferences = createTable()
tableSet(goToReferences, "id", -1)
tableSet(goToReferences, "input", "")
tableSet(goToReferences, "all", createArray())
tableSet(goToReferences, "results", createArray())
tableSet(goToReferences, "selected", 0)
tableSet(goToReferences, "previous_buffer_id", -1)

fn goToReferencesDisplay(entry) {
    let filePath = tableGet(entry, "file_path")
    let range = tableGet(entry, "range")
    let mark = tableGet(range, "mark")
    let row = tableGet(mark, "row") + 1
    let column = tableGet(mark, "column") + 1
    let preview = tableGet(entry, "preview")

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToReferences() {
    let ctx = createTable()
    tableSet(ctx, "title", "ðŸ”— References")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(goToReferences, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(goToReferences, "results"))
    tableSet(ctx, "selected_index", tableGet(goToReferences, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No references")
    tableSet(ctx, "buffer_id", tableGet(goToReferences, "id"))
    tableSet(ctx, "entry_to_string", goToReferencesDisplay)
    listPanelRender(ctx)
}

fn goToReferencesFilterResults() {
    let results = createArray()
    let query = stringToLower(tableGet(goToReferences, "input"))
    let allEntries = tableGet(goToReferences, "all")

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = arrayGet(allEntries, i)

        let filePath = stringToLower(tableGet(entry, "file_path"))
        let preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(goToReferences, "results", results)
    tableSet(goToReferences, "selected", 0)
    renderGoToReferences()
}

fn goToReferencesInputUpdated() {
    inputUpdated(tableGet(goToReferences, "id"), goToReferences, "input", goToReferencesFilterResults)
}

fn goToReferencesAddSpace() {
    inputAddSpace(tableGet(goToReferences, "id"), goToReferences, "input", renderGoToReferences)
}

fn goToReferencesBackspace() {
    inputBackspace(tableGet(goToReferences, "id"), goToReferences, "input", null)
}

fn goToReferencesClearInput() {
    inputClear(tableGet(goToReferences, "id"), goToReferences, "input", null)
}

fn goToReferencesMoveSelection(delta) {
    let results = tableGet(goToReferences, "results")
    let selected = listPanelMoveSelection(results, tableGet(goToReferences, "selected"), delta)
    tableSet(goToReferences, "selected", selected)
    renderGoToReferences()
}

fn goToReferencesNext() {
    goToReferencesMoveSelection(1)
}

fn goToReferencesPrevious() {
    goToReferencesMoveSelection(-1)
}

fn goToReferencesSelect() {
    let results = tableGet(goToReferences, "results")
    let selected = tableGet(goToReferences, "selected")
    if selected < arrayLen(results) {
        let entry = arrayGet(results, selected)
        let path = tableGet(entry, "file_path")
        let range = tableGet(entry, "range")

        goToReferencesClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToReferencesEscape() {
    let previousBufferId = tableGet(goToReferences, "previous_buffer_id")
    if previousBufferId != -1 {
        goToReferencesClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToReferencesReload() {
    let references = getReferences()
    tableSet(goToReferences, "all", fromJson(references))
    goToReferencesFilterResults()
}

fn createGoToReferences() {
    tableSet(goToReferences, "previous_buffer_id", getActiveBuffer())
    if tableGet(goToReferences, "id") == -1 {
        let bufferId = createSpecialBuffer("References")
        tableSet(goToReferences, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", goToReferencesAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToReferencesBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins down", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins up", goToReferencesPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToReferencesSelect)
        registerBufferKeybind(bufferId, "ins escape", goToReferencesEscape)
        registerBufferInputHook(bufferId, goToReferencesInputUpdated)
    }
    goToReferencesClearInput()
    goToReferencesReload()
    setActiveBuffer(tableGet(goToReferences, "id"))
    runAction("enter-insert-mode")
}

############

# Dialog Modal

let dialogModal = createTable()
tableSet(dialogModal, "id", -1)
tableSet(dialogModal, "previous_buffer_id", -1)
tableSet(dialogModal, "active", false)
tableSet(dialogModal, "input", "")
tableSet(dialogModal, "prompt", "")
tableSet(dialogModal, "callback", null)

fn setSearchQueryFromDialog(query) {
    setSearchQuery(query)
    runAction("find-next-with-query")
}

fn dialogModalRender() {
    let content = "ðŸ’¬ Dialog\n" + tableGet(dialogModal, "prompt") + "\nâ•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" + tableGet(dialogModal, "input") + "\n\nenter: submit | esc: cancel"
    setViewportBufferContent(tableGet(dialogModal, "id"), content)
}

fn dialogModalEnsureBuffer() {
    if tableGet(dialogModal, "id") == -1 {
        let bufferId = createSpecialBuffer("Dialog")
        tableSet(dialogModal, "id", bufferId)
        registerBufferKeybind(bufferId, "ins enter", dialogModalSubmit)
        registerBufferKeybind(bufferId, "ins escape", dialogModalClose)
        registerBufferKeybind(bufferId, "ins backspace", dialogModalBackspace)
        registerBufferKeybind(bufferId, "ins space", dialogModalInsertSpace)
        registerBufferInputHook(bufferId, dialogModalInputUpdated)
    }
}

fn dialogModalOpen(prompt, callback) {
    dialogModalEnsureBuffer()
    tableSet(dialogModal, "previous_buffer_id", getActiveBuffer())
    tableSet(dialogModal, "active", true)
    tableSet(dialogModal, "prompt", prompt)
    tableSet(dialogModal, "callback", callback)
    tableSet(dialogModal, "input", "")

    let bufferId = tableGet(dialogModal, "id")
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    dialogModalRender()
    runAction("enter-insert-mode")
}

fn dialogModalClose() {
    tableSet(dialogModal, "active", false)
    tableSet(dialogModal, "input", "")
    tableSet(dialogModal, "prompt", "")
    tableSet(dialogModal, "callback", null)
    let previousBufferId = tableGet(dialogModal, "previous_buffer_id")
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn dialogModalSubmit() {
    if !tableGet(dialogModal, "active") { return null }
    let value = getBufferInput(tableGet(dialogModal, "id"))
    let callback = tableGet(dialogModal, "callback")
    dialogModalClose()
    if callback != null {
        callback(value)
    }
}

fn dialogModalInputUpdated() {
    inputUpdated(tableGet(dialogModal, "id"), dialogModal, "input", dialogModalRender)
}

fn dialogModalInsertSpace() {
    inputAddSpace(tableGet(dialogModal, "id"), dialogModal, "input", dialogModalRender)
}

fn dialogModalBackspace() {
    let inputValue = getBufferInput(tableGet(dialogModal, "id"))
    let length = stringLen(inputValue)
    if length <= 0 { return null }
    inputValue = stringTruncateWidth(inputValue, length - 1)
    tableSet(dialogModal, "input", inputValue)
    setBufferInput(tableGet(dialogModal, "id"), inputValue)
    dialogModalRender()
}

############

# Info Modal

let infoModal = createTable()
tableSet(infoModal, "id", -1)
tableSet(infoModal, "previous_buffer_id", -1)
tableSet(infoModal, "content", "")
tableSet(infoModal, "scroll", 0)
tableSet(infoModal, "active", false)
tableSet(infoModal, "page_size", 48)

fn infoModalClampScroll(totalLines, pageSize) {
    let maxScroll = totalLines - pageSize
    if maxScroll < 0 { maxScroll = 0 }
    let infoModalScroll = tableGet(infoModal, "scroll")
    if infoModalScroll < 0 { infoModalScroll = 0 }
    if infoModalScroll > maxScroll { infoModalScroll = maxScroll }
    tableSet(infoModal, "scroll", infoModalScroll)
}

fn infoModalRender() {
    let content = "Info Modal (esc to close, up/down to scroll)\n------"
    let infoModalContent = tableGet(infoModal, "content")
    let columns = viewportVisibleColumns()
    let wrappedAll = stringRenderViewport(infoModalContent, columns, 100000, 0)
    let wrappedLines = stringSplitLines(wrappedAll)
    let totalLines = arrayLen(wrappedLines)

    if totalLines == 0 {
        content = content + "\n\n   No information available"
        setViewportBufferContent(tableGet(infoModal, "id"), content)
        return null
    }

    let visibleRows = viewportVisibleRows(0)
    let bodyRows = visibleRows - 3
    if bodyRows < 1 { bodyRows = 1 }

    let footerLines = 0
    if tableGet(infoModal, "scroll") + bodyRows < totalLines and bodyRows > 2 {
        footerLines = 2
        bodyRows = bodyRows - footerLines
    }

    tableSet(infoModal, "page_size", bodyRows)
    infoModalClampScroll(totalLines, bodyRows)

    let scroll = tableGet(infoModal, "scroll")
    let body = stringRenderViewport(infoModalContent, columns, bodyRows, scroll)
    content = content + "\n\n" + body

    let remaining = totalLines - (scroll + bodyRows)
    if remaining > 0 {
        content = content + "\n\n... (" + toJson(remaining) + " more lines)"
    }

    setViewportBufferContent(tableGet(infoModal, "id"), content)
}

fn infoModalEnsureBuffer() {
    if tableGet(infoModal, "id") == -1 {
        let bufferId = createSpecialBuffer("Info")
        tableSet(infoModal, "id", bufferId)
        registerBufferKeybind(bufferId, "ins escape", infoModalClose)
        registerBufferKeybind(bufferId, "ins up", infoModalScrollUp)
        registerBufferKeybind(bufferId, "ins down", infoModalScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", infoModalPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", infoModalPageDown)
    }
}

fn infoModalOpen(content) {
    infoModalEnsureBuffer()
    if !tableGet(infoModal, "active") {
        tableSet(infoModal, "previous_buffer_id", getActiveBuffer())
    }
    tableSet(infoModal, "active", true)
    tableSet(infoModal, "content", content)
    tableSet(infoModal, "scroll", 0)
    infoModalRender()
    let bufferId = tableGet(infoModal, "id")
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    runAction("enter-insert-mode")
}

fn infoModalClose() {
    tableSet(infoModal, "active", false)
    tableSet(infoModal, "scroll", 0)
    let previousBufferId = tableGet(infoModal, "previous_buffer_id")
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn infoModalScrollUp() {
    if !tableGet(infoModal, "active") { return null }
    let infoModalScroll = tableGet(infoModal, "scroll") - 1
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalScrollDown() {
    if !tableGet(infoModal, "active") { return null }
    let infoModalScroll = tableGet(infoModal, "scroll") + 1
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalPageUp() {
    if !tableGet(infoModal, "active") { return null }
    let infoModalScroll = tableGet(infoModal, "scroll") - tableGet(infoModal, "page_size")
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalPageDown() {
    if !tableGet(infoModal, "active") { return null }
    let infoModalScroll = tableGet(infoModal, "scroll") + tableGet(infoModal, "page_size")
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

##############

fn rerenderAllUi() {
    renderDashboard()

    if tableGet(llmChat, "id") != -1 { renderLLMChat() }
    if tableGet(fuzzyFileFinder, "id") != -1 { renderFuzzyFileFinder() }
    if tableGet(switchBuffer, "id") != -1 { renderSwitchBuffer() }
    if tableGet(workspaceSearch, "id") != -1 { renderWorkspaceSearch() }
    if tableGet(workspaceDiagnostics, "id") != -1 { renderWorkspaceDiagnostics() }
    if tableGet(commandDispatcher, "id") != -1 { renderCommandDispatcher() }
    if tableGet(goToDefinition, "id") != -1 { renderGoToDefinition() }
    if tableGet(goToReferences, "id") != -1 { renderGoToReferences() }
    if tableGet(dialogModal, "active") { dialogModalRender() }
    if tableGet(infoModal, "active") { infoModalRender() }
}

createDashboardBuffer()
refreshViewportSize()
runAction("set-init-rsl-complete")
