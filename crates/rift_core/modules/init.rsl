# Callbacks

fn onViewportSizeChanged(rows, columns) {
    setViewportSize(rows, columns)
}

# UI Helper Methods

fn setViewportSize(rows, columns) {
    viewportRows = rows
    viewportColumns = columns
    rerenderAllUi()
}

fn refreshViewportSize() {
    size = fromJson(getViewportSize())
    setViewportSize(tableGet(size, "rows"), tableGet(size, "columns"))
}

fn viewportVisibleRows(reservedLines) {
    # Keep a reasonable default even if the viewport has not reported yet.
    available = viewportRows - reservedLines
    if available < 5 { available = 5 }
    return available
}

fn viewportVisibleColumns() {
    # Rendering reserves 3 columns (see RopeBuffer::get_visible_lines); clamp to visible width.
    columns = viewportColumns
    if columns <= 0 { columns = 20 }
    columns = columns - 3
    if columns < 1 { columns = 1 }
    return columns
}

fn clampLineToViewport(line, columns) {
    if columns <= 0 { return "" }
    if stringWidth(line) <= columns { return line }

    ellipsis = "â€¦"
    ellipsisWidth = stringWidth(ellipsis)

    if ellipsisWidth >= columns { return stringTruncateWidth(ellipsis, columns) }

    available = columns - ellipsisWidth
    if available < 0 { available = 0 }
    return stringTruncateWidth(line, available) + ellipsis
}

fn clampContentToViewport(content) {
    columns = viewportVisibleColumns()
    lines = stringSplitLines(content)
    clamped = ""

    i = 0
    loop {
        if i >= arrayLen(lines) { break }
        line = arrayGet(lines, i)
        clampedLine = clampLineToViewport(line, columns)
        if i > 0 { clamped = clamped + "\n" }
        clamped = clamped + clampedLine
        i = i + 1
    }

    return clamped
}

fn setViewportBufferContent(bufferId, content) {
    setBufferContent(bufferId, clampContentToViewport(content))
}

fn viewportWindow(selectedIndex, totalItems, reservedLines) {
    window = createTable()
    if totalItems <= 0 {
        tableSet(window, "start", 0)
        tableSet(window, "end", 0)
        return window
    }

    visible = viewportVisibleRows(reservedLines)
    if visible > totalItems { visible = totalItems }

    start = floor(selectedIndex - (visible / 2))
    if start < 0 { start = 0 }
    end = start + visible
    if end > totalItems {
        end = totalItems
        start = end - visible
        if start < 0 { start = 0 }
    }

    tableSet(window, "start", start)
    tableSet(window, "end", end)
    return window
}

# Shared List + Input Helpers

fn listPanelMoveSelection(entries, selectedIndex, delta) {
    total = arrayLen(entries)
    if total == 0 { return 0 }
    nextIndex = selectedIndex + delta
    if nextIndex < 0 { nextIndex = total - 1 }
    if nextIndex >= total { nextIndex = 0 }
    return nextIndex
}

fn listPanelRender(ctx) {
    title = tableGet(ctx, "title")
    inputHeader = tableGet(ctx, "input_header")
    inputValue = tableGet(ctx, "input_value")
    listHeader = tableGet(ctx, "list_header")
    entries = tableGet(ctx, "entries")
    selectedIndex = tableGet(ctx, "selected_index")
    reservedLines = tableGet(ctx, "reserved_lines")
    emptyText = tableGet(ctx, "empty_text")
    bufferId = tableGet(ctx, "buffer_id")
    entryToString = tableGet(ctx, "entry_to_string")
    headerLines = tableGet(ctx, "header_lines")
    extraLines = tableGet(ctx, "extra_lines")

    content = title
    if headerLines != null {
        i = 0
        loop {
            if i >= arrayLen(headerLines) { break }
            content = content + "\n" + arrayGet(headerLines, i)
            i = i + 1
        }
    }

    content = content + "\n" + inputHeader + "\n" + inputValue + "\n" + listHeader

    if extraLines != null {
        i = 0
        loop {
            if i >= arrayLen(extraLines) { break }
            content = content + "\n" + arrayGet(extraLines, i)
            i = i + 1
        }
    }

    total = arrayLen(entries)
    if total == 0 {
        content = content + "\n   " + emptyText
        setViewportBufferContent(bufferId, content)
        return null
    }

    if reservedLines == null { reservedLines = 5 }
    window = viewportWindow(selectedIndex, total, reservedLines)
    start = tableGet(window, "start")
    end = tableGet(window, "end")

    if start > 0 { content = content + "\n   â‹¯" }

    i = start
    loop {
        if i >= end { break }
        entry = arrayGet(entries, i)
        display = entry
        if entryToString != null {
            display = entryToString(entry)
        }
        prefix = "â€¢"
        if selectedIndex == i { prefix = "âž¤" }
        content = content + "\n " + prefix + " " + display
        i = i + 1
    }

    if end < total { content = content + "\n   â‹¯" }

    setViewportBufferContent(bufferId, content)
}

fn inputGet(bufferId) {
    return getBufferInput(bufferId)
}

fn inputSet(bufferId, value) {
    setBufferInput(bufferId, value)
}

fn inputUpdated(bufferId, stateTable, key, onUpdated) {
    value = getBufferInput(bufferId)
    tableSet(stateTable, key, value)
    if onUpdated != null { onUpdated() }
}

fn inputAddSpace(bufferId, stateTable, key, onUpdated) {
    value = getBufferInput(bufferId)
    value = value + " "
    tableSet(stateTable, key, value)
    setBufferInput(bufferId, value)
    if onUpdated != null { onUpdated() }
}

fn inputBackspace(bufferId, stateTable, key, onCleared) {
    value = getBufferInput(bufferId)
    length = stringLen(value)
    if length <= 0 { return null }
    value = stringTruncateWidth(value, length - 1)
    tableSet(stateTable, key, value)
    setBufferInput(bufferId, value)
    if onCleared != null { onCleared() }
}

fn inputClear(bufferId, stateTable, key, onCleared) {
    tableSet(stateTable, key, "")
    setBufferInput(bufferId, "")
    if onCleared != null { onCleared() }
}

# Dashboard

viewportRows = 0
viewportColumns = 0
dashboard = createTable()
tableSet(dashboard, "id", -1)
tableSet(dashboard, "text", "
Welcome to rift!

Basic Keybinds:

esc - Quit Insert Mode
i - Enter Insert Mode
space q - Quit
space f - Fuzzy File Picker (with fd & fzf)
space F - File Explorer
space b - Switch Buffer
")

fn renderDashboard() {
    dashboardId = tableGet(dashboard, "id")
    if dashboardId == -1 { return null }
    content = tableGet(dashboard, "text") + "\nViewport: " + toString(viewportRows) + " x " + toString(viewportColumns)
    setViewportBufferContent(dashboardId, content)
}

fn createDashboardBuffer() {
    dashboardId = tableGet(dashboard, "id")
    if dashboardId == -1 {
        bufferId = createSpecialBuffer("Dashboard")
        tableSet(dashboard, "id", bufferId)
        activeBuffer = getActiveBuffer()
        if activeBuffer == null {
            setActiveBuffer(bufferId)
        }
    }
    renderDashboard()
}

#################

# Agentic Chat

fn toolDeclarations() {
    return
"[
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"run_shell_command\",
            \"description\": \"Run a shell command and return the output\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"command\": {\"type\": \"string\"}
                },
                \"required\": [\"command\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"find_file\",
            \"description\": \"Returns paths matching regex pattern by searching recursively in the workspace folder, returning absolute paths. Does not accept glob patterns.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"search_workspace\",
            \"description\": \"Grep search in the current workspace for matching patterns\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"read_file\",
            \"description\": \"Get the content of a file with line numbers\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"path\": {\"type\": \"string\"}
                },
                \"required\": [\"path\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"write_file\",
            \"description\": \"Writes content to a specified file replacing the existing content.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"content\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"content\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"replace\",
            \"description\": \"Replaces text within a file. Can replace single or multiple occurrences.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"old_string\": {\"type\": \"string\"},
                    \"new_string\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"old_string\", \"new_string\"]
            }
        }
    }
]"
}

fn agentRunShellCommand(command) {
    outputs = runShellCommand(command, getWorkspaceDir())
    return "STDOUT:\n" + tableGet(outputs, "stdout") + "\nSTDERR:\n" + tableGet(outputs, "stderr")
}

fn agentFindFile(pattern) {
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

fn agentSearchWorkspace(pattern) {
    results = runShellCommand("rg " + pattern, getWorkspaceDir())
    return tableGet(results, "stdout")
}

fn getOpenRouterProvider() {
    provider = createTable()
    tableSet(provider, "url", "https://openrouter.ai/api/v1/chat/completions")
    tableSet(provider, "api_key", getEnvVar("OPENROUTER_KEY"))
    tableSet(provider, "model", "mistralai/devstral-small")
    return provider
}

fn getLlamaCppProvider() {
    provider = createTable()
    tableSet(provider, "url", "http://127.0.0.1:8080/v1/chat/completions")
    tableSet(provider, "api_key", null)
    tableSet(provider, "model", "Granite-4.0-H-Tiny")
    return provider
}

openRouterProvider = getOpenRouterProvider()
llamaCppProvider = getLlamaCppProvider()

llmChat = createTable()
tableSet(llmChat, "id", -1)
tableSet(llmChat, "provider", llamaCppProvider)
tableSet(llmChat, "history_scroll", 0)
tableSet(llmChat, "history_page_size", 1)
tableSet(llmChat, "input", "")
tableSet(llmChat, "history", createArray())
tableSet(llmChat, "pending_tool_calls", createArray())

fn llmChatRoleLabel(message) {
    role = tableGet(message, "role")
    label = role
    if role == "assistant" { label = "Assistant" }
    if role == "user" { label = "User" }
    if role == "system" { label = "System" }
    if role == "tool" {
        label = "Tool"
        name = tableGet(message, "name")
        if name != null {
            label = "Tool (" + name + ")"
        }
    }
    return label
}

fn llmChatToolCallName(toolCall) {
    toolFunc = tableGet(toolCall, "function")
    if toolFunc == null { return "unknown" }
    name = tableGet(toolFunc, "name")
    if name == null { return "unknown" }
    return name
}

fn llmChatLinesToString(lines) {
    text = ""
    i = 0
    loop {
        if i >= arrayLen(lines) { break }
        line = arrayGet(lines, i)
        if i > 0 { text = text + "\n" }
        text = text + line
        i = i + 1
    }
    return text
}

fn llmChatScrollUp() {
    llmChatHistoryScroll = tableGet(llmChat, "history_scroll") + 1
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatScrollDown() {
    llmChatHistoryScroll = tableGet(llmChat, "history_scroll") - 1
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatPageUp() {
    llmChatHistoryScroll = tableGet(llmChat, "history_scroll") + tableGet(llmChat, "history_page_size")
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn llmChatPageDown() {
    llmChatHistoryScroll = tableGet(llmChat, "history_scroll") - tableGet(llmChat, "history_page_size")
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    renderLLMChat()
}

fn renderLLMChat() {
    chatHistory = tableGet(llmChat, "history")
    historyLines = createArray()
    totalMessages = arrayLen(chatHistory)
    i = 0
    loop {
        if i >= totalMessages { break }
        message = arrayGet(chatHistory, i)
        label = llmChatRoleLabel(message)
        arrayPushBack(historyLines, label + ":")
        content = tableGet(message, "content")
        if content == null { content = "" }
        contentLines = stringSplitLines(content)
        if arrayLen(contentLines) == 0 or stringLen(content) == 0 {
            arrayPushBack(historyLines, "  (empty)")
        }
        if arrayLen(contentLines) != 0 and stringLen(content) != 0 {
            j = 0
            loop {
                if j >= arrayLen(contentLines) { break }
                line = arrayGet(contentLines, j)
                arrayPushBack(historyLines, "  " + line)
                j = j + 1
            }
        }
        toolCalls = tableGet(message, "tool_calls")
        if toolCalls != null {
            j = 0
            loop {
                if j >= arrayLen(toolCalls) { break }
                toolCall = arrayGet(toolCalls, j)
                toolName = llmChatToolCallName(toolCall)
                arrayPushBack(historyLines, "  â€¢ tool call: " + toolName)
                j = j + 1
            }
        }
        if i < totalMessages - 1 {
            arrayPushBack(historyLines, "")
        }
        i = i + 1
    }

    historyContent = ""
    if arrayLen(historyLines) == 0 {
        historyContent = "   No messages yet"
    }
    if arrayLen(historyLines) != 0 {
        historyContent = llmChatLinesToString(historyLines)
    }

    pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    pendingLines = createArray()
    if arrayLen(pendingToolCalls) == 0 {
        arrayPushBack(pendingLines, "   None")
    }
    if arrayLen(pendingToolCalls) != 0 {
        i = 0
        loop {
            if i >= arrayLen(pendingToolCalls) { break }
            toolCall = arrayGet(pendingToolCalls, i)
            toolName = llmChatToolCallName(toolCall)
            arrayPushBack(pendingLines, " â€¢ " + toolName)
            i = i + 1
        }
    }

    chatInput = tableGet(llmChat, "input")
    inputLines = stringSplitLines(chatInput)
    if arrayLen(inputLines) == 0 or stringLen(chatInput) == 0 {
        inputLines = createArray()
        arrayPushBack(inputLines, "Type a message...")
    }

    headerLines = 3
    sectionLines = 3
    reservedLines = headerLines + sectionLines + arrayLen(pendingLines) + arrayLen(inputLines)
    historyRows = viewportVisibleRows(reservedLines)
    if historyRows < 1 { historyRows = 1 }

    columns = viewportVisibleColumns()
    wrappedAll = stringRenderViewport(historyContent, columns, 100000, 0)
    wrappedLines = stringSplitLines(wrappedAll)
    totalHistoryLines = arrayLen(wrappedLines)
    if totalHistoryLines < 1 { totalHistoryLines = 1 }

    llmChatHistoryScroll = tableGet(llmChat, "history_scroll")
    showEllipsis = llmChatHistoryScroll > 0
    if showEllipsis and historyRows <= 1 { showEllipsis = false }
    if showEllipsis { historyRows = historyRows - 1 }

    maxScroll = totalHistoryLines - historyRows
    if maxScroll < 0 { maxScroll = 0 }
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    if llmChatHistoryScroll > maxScroll { llmChatHistoryScroll = maxScroll }
    tableSet(llmChat, "history_scroll", llmChatHistoryScroll)
    tableSet(llmChat, "history_page_size", historyRows)

    historyBody = stringRenderViewport(historyContent, columns, historyRows, -1 * (llmChatHistoryScroll + 1))
    provider = tableGet(llmChat, "provider")
    modelName = "unknown"
    if provider != null { modelName = tableGet(provider, "model") }
    status = "Model: " + modelName + " | Pending tools: " + toString(arrayLen(pendingToolCalls))

    content = "ðŸ¤– LLM Chat\n" + status + "\nenter: send | y/n: allow/deny tool | up/down: scroll\n"
    content = content + "â•­â”€ History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    if showEllipsis { content = content + "   â‹¯\n" }
    content = content + historyBody + "\n"
    content = content + "â•°â”€ Pending Tools â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(pendingLines) + "\n"
    content = content + "â•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(inputLines)

    setViewportBufferContent(tableGet(llmChat, "id"), content)
}

fn requestChatCompletion() {
    provider = tableGet(llmChat, "provider")
    if provider == null { return null }

    apiKey = tableGet(provider, "api_key")
    modelName = tableGet(provider, "model")
    url = tableGet(provider, "url")

    request = createTable()
    tableSet(request, "model", modelName)
    tableSet(request, "messages", tableGet(llmChat, "history"))
    tableSet(request, "tools", fromJson(toolDeclarations()))
    tableSet(request, "stream", false)
    tableSet(request, "temperature", 0.3)
    tableSet(request, "seed", 42)

    body = toJson(request)
    hasApiKey = apiKey != null and stringLen(apiKey) != 0
    response = null
    if hasApiKey { response = postRequestWithBearerToken(url, body, apiKey) }
    if !hasApiKey { response = postRequest(url, body) }
    response = fromJson(response)
    message = tableGet(arrayGet(tableGet(response, "choices"), 0), "message")
    toolCalls = tableGet(message, "tool_calls")
    
    if toolCalls != null {
        pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
        i = arrayLen(toolCalls)
        loop {
            if i <= 0 { break }
            toolCall = arrayGet(toolCalls, i - 1)
            
            arrayPushBack(pendingToolCalls, toolCall)
            
            toolName = tableGet(tableGet(toolCall, "function"), "name")
            toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
            toolCallId = tableGet(toolCall, "id")
            
            i = i - 1
        }
    }
    
    arrayPushBack(tableGet(llmChat, "history"), message)

    renderLLMChat()
}

fn getToolCallResult(allowed) {
    pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    toolCall = arrayPopBack(pendingToolCalls)
    
    toolName = tableGet(tableGet(toolCall, "function"), "name")
    toolArgs = fromJson(tableGet(tableGet(toolCall, "function"), "arguments"))
    toolCallId = tableGet(toolCall, "id")
    
    result = "Tool call request denied by user. Await further instructions."
    
    if allowed {
        if toolName == "run_shell_command" {
            result = agentRunShellCommand(tableGet(toolArgs, "command"))
        }
        if toolName == "find_file" {
            result = agentFindFile(tableGet(toolArgs, "pattern"))
        }
        if toolName == "search_workspace" {
            result = agentSearchWorkspace(tableGet(toolArgs, "pattern"))
        }
        if toolName == "read_file" {
            result = agentReadFile(getWorkspaceDir(), tableGet(toolArgs, "path"))
        }
        if toolName == "write_file" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "content"))
        }
        if toolName == "replace" {
            result = agentFindFile(getWorkspaceDir(), tableGet(toolArgs, "file_path"), tableGet(toolArgs, "old_string"), tableGet(toolArgs, "new_string"))
        }
    }
    
    message = createTable()
    tableSet(message, "role", "tool")
    tableSet(message, "content", result)
    tableSet(message, "name", toolName)
    tableSet(message, "tool_call_id", toolCallId)
    arrayPushBack(tableGet(llmChat, "history"), message)
    
    renderLLMChat()

    if arrayLen(pendingToolCalls) == 0 {
        requestChatCompletion()
    }
}

fn allowToolCall() { getToolCallResult(true) }
fn denyToolCall() { getToolCallResult(false) }

fn sendMessage() {
    pendingToolCalls = tableGet(llmChat, "pending_tool_calls")
    if arrayLen(pendingToolCalls) == 0 {
        message = createTable()
        tableSet(message, "role", "user")
        tableSet(message, "content", tableGet(llmChat, "input"))
        arrayPushBack(tableGet(llmChat, "history"), message)

        llmChatClearInput()
        renderLLMChat()
    
        requestChatCompletion()
    }
}

fn llmChatInputUpdated() {
    inputUpdated(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatAddSpace() {
    inputAddSpace(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatBackspace() {
    inputBackspace(tableGet(llmChat, "id"), llmChat, "input", renderLLMChat)
}

fn llmChatClearInput() {
    inputClear(tableGet(llmChat, "id"), llmChat, "input", null)
}

fn createLLMChat() {
    if tableGet(llmChat, "id") == -1 {
        bufferId = createSpecialBuffer("LLM Chat")
        tableSet(llmChat, "id", bufferId)
        registerBufferKeybind(bufferId, "ins enter", sendMessage)
        registerBufferKeybind(bufferId, "nor up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "nor down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "nor pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "nor pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "ins space", llmChatAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", llmChatBackspace)
        registerBufferKeybind(bufferId, "ins up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "ins down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "nor y", allowToolCall)
        registerBufferKeybind(bufferId, "nor n", denyToolCall)
        registerBufferInputHook(bufferId, llmChatInputUpdated)
        renderLLMChat()
    }
    setActiveBuffer(tableGet(llmChat, "id"))
}

registerGlobalKeybind("nor space c", createLLMChat)

############

# Fuzzy Find File

fn fuzzyFileFinderDependenciesAvailable() {
    return commandExists("fd") and commandExists("fzf")
}

fn fuzzyFileFinderDependenciesError() {
    infoModalOpen("Fuzzy File Finder requires `fd` and `fzf` to be installed and available in PATH.")
}

fuzzyFileFinder = createTable()
tableSet(fuzzyFileFinder, "id", -1)
tableSet(fuzzyFileFinder, "input", "")
tableSet(fuzzyFileFinder, "results", createArray())
tableSet(fuzzyFileFinder, "selected", 0)
tableSet(fuzzyFileFinder, "previous_buffer_id", -1)

fn renderFuzzyFileFinder() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ”Ž Fuzzy File Finder")
    tableSet(ctx, "input_header", "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(fuzzyFileFinder, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(fuzzyFileFinder, "results"))
    tableSet(ctx, "selected_index", tableGet(fuzzyFileFinder, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No files found")
    tableSet(ctx, "buffer_id", tableGet(fuzzyFileFinder, "id"))
    listPanelRender(ctx)
}

fn fuzzyFileFinderWorkspaceEntries() {
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path", getWorkspaceDir())
    tableSet(fuzzyFileFinder, "results", stringSplitLines(tableGet(results, "stdout")))
    tableSet(fuzzyFileFinder, "selected", 0)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderInputUpdated() {
    inputUpdated(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
    results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path | fzf -f \"" + tableGet(fuzzyFileFinder, "input") + "\"", getWorkspaceDir())
    tableSet(fuzzyFileFinder, "results", stringSplitLines(tableGet(results, "stdout")))
    tableSet(fuzzyFileFinder, "selected", 0)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderAddSpace() {
    inputAddSpace(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", renderFuzzyFileFinder)
}

fn fuzzyFileFinderBackspace() {
    inputBackspace(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderClearInput() {
    inputClear(tableGet(fuzzyFileFinder, "id"), fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderMoveSelection(delta) {
    results = tableGet(fuzzyFileFinder, "results")
    selected = listPanelMoveSelection(results, tableGet(fuzzyFileFinder, "selected"), delta)
    tableSet(fuzzyFileFinder, "selected", selected)
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderNext() {
    fuzzyFileFinderMoveSelection(1)
}

fn fuzzyFileFinderPrevious() {
    fuzzyFileFinderMoveSelection(-1)
}

fn fuzzyFileFinderSelect() {
    results = tableGet(fuzzyFileFinder, "results")
    selected = tableGet(fuzzyFileFinder, "selected")
    if selected < arrayLen(results) {
        path = arrayGet(results, selected)
        fuzzyFileFinderClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fuzzyFileFinderEscape() {
    previousBufferId = tableGet(fuzzyFileFinder, "previous_buffer_id")
    if previousBufferId != -1 {
        fuzzyFileFinderClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createFuzzyFileFinder() {
    if !fuzzyFileFinderDependenciesAvailable() {
        fuzzyFileFinderDependenciesError()
        return null
    }
    tableSet(fuzzyFileFinder, "previous_buffer_id", getActiveBuffer())
    if tableGet(fuzzyFileFinder, "id") == -1 {
        bufferId = createSpecialBuffer("Fuzzy File Finder")
        tableSet(fuzzyFileFinder, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", fuzzyFileFinderAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fuzzyFileFinderBackspace)
        registerBufferKeybind(bufferId, "ins tab", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins down", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins up", fuzzyFileFinderPrevious)
        registerBufferKeybind(bufferId, "ins enter", fuzzyFileFinderSelect)
        registerBufferKeybind(bufferId, "ins escape", fuzzyFileFinderEscape)
        registerBufferInputHook(bufferId, fuzzyFileFinderInputUpdated)
    }
    fuzzyFileFinderClearInput()
    setActiveBuffer(tableGet(fuzzyFileFinder, "id"))
    fuzzyFileFinderWorkspaceEntries()
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space f", createFuzzyFileFinder)

############

# File Explorer

fileExplorer = createTable()
tableSet(fileExplorer, "id", -1)
tableSet(fileExplorer, "input", "")
tableSet(fileExplorer, "entries", createArray())
tableSet(fileExplorer, "all_entries", createArray())
tableSet(fileExplorer, "selected", 0)
tableSet(fileExplorer, "current_dir", "")
tableSet(fileExplorer, "previous_buffer_id", -1)
tableSet(fileExplorer, "error", "")

fn fileExplorerEntryDisplay(entry) {
    name = tableGet(entry, "name")
    if tableGet(entry, "is_dir") {
        return name + "/"
    }
    return name
}

fn renderFileExplorer() {
    headerLines = createArray()
    arrayPushBack(headerLines, tableGet(fileExplorer, "current_dir"))
    arrayPushBack(headerLines, "(ctrl-f: new file, ctrl-d: new folder)")

    extraLines = null
    errorMessage = tableGet(fileExplorer, "error")
    if errorMessage != "" {
        extraLines = createArray()
        arrayPushBack(extraLines, "   Error: " + errorMessage)
    }

    ctx = createTable()
    tableSet(ctx, "title", "ðŸ“‚ File Explorer")
    tableSet(ctx, "header_lines", headerLines)
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(fileExplorer, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Entries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(fileExplorer, "entries"))
    tableSet(ctx, "selected_index", tableGet(fileExplorer, "selected"))
    tableSet(ctx, "reserved_lines", 6)
    tableSet(ctx, "empty_text", "No entries")
    tableSet(ctx, "buffer_id", tableGet(fileExplorer, "id"))
    tableSet(ctx, "entry_to_string", fileExplorerEntryDisplay)
    tableSet(ctx, "extra_lines", extraLines)
    listPanelRender(ctx)
}

fn fileExplorerApplyFilter() {
    query = stringToLower(tableGet(fileExplorer, "input"))
    entries = createArray()
    allEntries = tableGet(fileExplorer, "all_entries")

    i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        entry = arrayGet(allEntries, i)
        name = stringToLower(tableGet(entry, "name"))

        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(entries, entry)
        }

        i = i + 1
    }

    tableSet(fileExplorer, "entries", entries)

    if arrayLen(entries) == 0 {
        tableSet(fileExplorer, "selected", 0)
    }
    if tableGet(fileExplorer, "selected") >= arrayLen(entries) {
        tableSet(fileExplorer, "selected", 0)
    }

    renderFileExplorer()
}

fn fileExplorerRefreshEntries() {
    listing = listDir(tableGet(fileExplorer, "current_dir"))
    allEntries = createArray()
    tableSet(fileExplorer, "error", "")

    errorMessage = tableGet(listing, "error")
    if errorMessage != null {
        tableSet(fileExplorer, "error", errorMessage)
    }

    entries = tableGet(listing, "entries")

    parentEntry = createTable()
    tableSet(parentEntry, "name", "..")
    tableSet(parentEntry, "path", parentPath(tableGet(fileExplorer, "current_dir")))
    tableSet(parentEntry, "is_dir", true)
    arrayPushBack(allEntries, parentEntry)

    i = 0
    loop {
        if i >= arrayLen(entries) { break }
        entry = arrayGet(entries, i)
        arrayPushBack(allEntries, entry)
        i = i + 1
    }

    tableSet(fileExplorer, "all_entries", allEntries)
    tableSet(fileExplorer, "selected", 0)
    fileExplorerApplyFilter()
}

fn fileExplorerSetDirectory(path) {
    tableSet(fileExplorer, "current_dir", path)
    fileExplorerRefreshEntries()
}

fn fileExplorerInputUpdated() {
    inputUpdated(tableGet(fileExplorer, "id"), fileExplorer, "input", fileExplorerApplyFilter)
}

fn fileExplorerAddSpace() {
    inputAddSpace(tableGet(fileExplorer, "id"), fileExplorer, "input", renderFileExplorer)
}

fn fileExplorerBackspace() {
    inputBackspace(tableGet(fileExplorer, "id"), fileExplorer, "input", null)
}

fn fileExplorerClearInput() {
    inputClear(tableGet(fileExplorer, "id"), fileExplorer, "input", null)
}

fn fileExplorerMoveSelection(delta) {
    entries = tableGet(fileExplorer, "entries")
    selected = listPanelMoveSelection(entries, tableGet(fileExplorer, "selected"), delta)
    tableSet(fileExplorer, "selected", selected)
    renderFileExplorer()
}

fn fileExplorerNext() {
    fileExplorerMoveSelection(1)
}

fn fileExplorerPrevious() {
    fileExplorerMoveSelection(-1)
}

fn fileExplorerSelect() {
    entries = tableGet(fileExplorer, "entries")
    selected = tableGet(fileExplorer, "selected")
    if selected < arrayLen(entries) {
        entry = arrayGet(entries, selected)
        path = tableGet(entry, "path")
        if tableGet(entry, "is_dir") {
            fileExplorerClearInput()
            fileExplorerSetDirectory(path)
            return null
        }
        fileExplorerClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerEscape() {
    previousBufferId = tableGet(fileExplorer, "previous_buffer_id")
    if previousBufferId != -1 {
        fileExplorerClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerCreateFileSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("File name cannot be empty.")
        return null
    }

    targetPath = joinPath(tableGet(fileExplorer, "current_dir"), pathInput)
    result = createBlankFile(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerRefreshEntries()
    openFile(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFilePrompt() {
    prompt = "Create File\n" + tableGet(fileExplorer, "current_dir") + "\nEnter file name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFileSubmit)
}

fn fileExplorerCreateFolderSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("Folder name cannot be empty.")
        return null
    }

    targetPath = joinPath(tableGet(fileExplorer, "current_dir"), pathInput)
    result = createDirectory(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerSetDirectory(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFolderPrompt() {
    prompt = "Create Folder\n" + tableGet(fileExplorer, "current_dir") + "\nEnter folder name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFolderSubmit)
}

fn createFileExplorer() {
    tableSet(fileExplorer, "previous_buffer_id", getActiveBuffer())

    if tableGet(fileExplorer, "id") == -1 {
        bufferId = createSpecialBuffer("File Explorer")
        tableSet(fileExplorer, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", fileExplorerAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fileExplorerBackspace)
        registerBufferKeybind(bufferId, "ins tab", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins down", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins up", fileExplorerPrevious)
        registerBufferKeybind(bufferId, "ins enter", fileExplorerSelect)
        registerBufferKeybind(bufferId, "ins escape", fileExplorerEscape)
        registerBufferKeybind(bufferId, "ins c-f", fileExplorerCreateFilePrompt)
        registerBufferKeybind(bufferId, "ins c-d", fileExplorerCreateFolderPrompt)
        registerBufferInputHook(bufferId, fileExplorerInputUpdated)
    }

    fileExplorerClearInput()
    fileExplorerSetDirectory(getWorkspaceDir())
    setActiveBuffer(tableGet(fileExplorer, "id"))
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space s-f", createFileExplorer)

############

# Switch Buffer

switchBuffer = createTable()
tableSet(switchBuffer, "id", -1)
tableSet(switchBuffer, "input", "")
tableSet(switchBuffer, "results", createArray())
tableSet(switchBuffer, "buffers", createArray())
tableSet(switchBuffer, "selected", 0)
tableSet(switchBuffer, "selected_id", -1)
tableSet(switchBuffer, "previous_buffer_id", -1)
tableSet(switchBuffer, "initial_active_id", -1)

fn switchBufferDisplay(entry) {
    display = tableGet(entry, "display_name")
    if tableGet(entry, "special") {
        display = "[special] " + display
    }
    if tableGet(entry, "modified") {
        display = display + " *"
    }
    if tableGet(entry, "is_active") {
        display = display + " (active)"
    }
    return display
}

fn renderSwitchBuffer() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ—‚ Switch Buffer")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(switchBuffer, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Buffers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(switchBuffer, "results"))
    tableSet(ctx, "selected_index", tableGet(switchBuffer, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No buffers")
    tableSet(ctx, "buffer_id", tableGet(switchBuffer, "id"))
    tableSet(ctx, "entry_to_string", switchBufferDisplay)
    listPanelRender(ctx)
}

fn switchBufferLoadBuffers() {
    buffers = listBuffers()
    tableSet(switchBuffer, "buffers", fromJson(buffers))
}

fn switchBufferUpdateSelectionFromId(targetId) {
    results = tableGet(switchBuffer, "results")
    if arrayLen(results) == 0 {
        tableSet(switchBuffer, "selected", 0)
        tableSet(switchBuffer, "selected_id", -1)
        renderSwitchBuffer()
        return null
    }

    selectedEntry = 0
    i = 0
    loop {
        if i >= arrayLen(results) { break }
        entry = arrayGet(results, i)
        if tableGet(entry, "id") == targetId {
            selectedEntry = i
            break
        }
        i = i + 1
    }

    selectedEntryValue = arrayGet(results, selectedEntry)
    tableSet(switchBuffer, "selected", selectedEntry)
    tableSet(switchBuffer, "selected_id", tableGet(selectedEntryValue, "id"))
    renderSwitchBuffer()
}

fn switchBufferUpdateResults() {
    switchBufferLoadBuffers()

    previousSelectionId = tableGet(switchBuffer, "selected_id")
    if previousSelectionId == -1 {
        previousSelectionId = tableGet(switchBuffer, "initial_active_id")
    }

    query = stringToLower(tableGet(switchBuffer, "input"))
    results = createArray()
    buffers = tableGet(switchBuffer, "buffers")

    i = 0
    loop {
        if i >= arrayLen(buffers) { break }
        entry = arrayGet(buffers, i)
        name = stringToLower(tableGet(entry, "display_name"))
        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(switchBuffer, "results", results)
    tableSet(switchBuffer, "selected_id", -1)
    tableSet(switchBuffer, "selected", 0)
    switchBufferUpdateSelectionFromId(previousSelectionId)
}

fn switchBufferInputUpdated() {
    inputUpdated(tableGet(switchBuffer, "id"), switchBuffer, "input", switchBufferUpdateResults)
}

fn switchBufferAddSpace() {
    inputAddSpace(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferBackspace() {
    inputBackspace(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferClearInput() {
    inputClear(tableGet(switchBuffer, "id"), switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferMoveSelection(delta) {
    results = tableGet(switchBuffer, "results")
    selected = listPanelMoveSelection(results, tableGet(switchBuffer, "selected"), delta)
    tableSet(switchBuffer, "selected", selected)
    if arrayLen(results) == 0 {
        tableSet(switchBuffer, "selected_id", -1)
    }
    if arrayLen(results) != 0 {
        entry = arrayGet(results, selected)
        tableSet(switchBuffer, "selected_id", tableGet(entry, "id"))
    }
    renderSwitchBuffer()
}

fn switchBufferNext() {
    switchBufferMoveSelection(1)
}

fn switchBufferPrevious() {
    switchBufferMoveSelection(-1)
}

fn switchBufferSelect() {
    results = tableGet(switchBuffer, "results")
    selected = tableGet(switchBuffer, "selected")
    if selected < arrayLen(results) {
        selection = arrayGet(results, selected)
        bufferId = tableGet(selection, "id")
        switchBufferClearInput()
        setActiveBuffer(bufferId)
        runAction("quit-insert-mode")
    }
}

fn switchBufferEscape() {
    previousBufferId = tableGet(switchBuffer, "previous_buffer_id")
    if previousBufferId != -1 {
        switchBufferClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createSwitchBuffer() {
    previousBufferId = getActiveBuffer()
    tableSet(switchBuffer, "previous_buffer_id", previousBufferId)
    tableSet(switchBuffer, "initial_active_id", previousBufferId)
    tableSet(switchBuffer, "selected_id", -1)

    if tableGet(switchBuffer, "id") == -1 {
        bufferId = createSpecialBuffer("Switch Buffer")
        tableSet(switchBuffer, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", switchBufferAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", switchBufferBackspace)
        registerBufferKeybind(bufferId, "ins tab", switchBufferNext)
        registerBufferKeybind(bufferId, "ins down", switchBufferNext)
        registerBufferKeybind(bufferId, "ins up", switchBufferPrevious)
        registerBufferKeybind(bufferId, "ins enter", switchBufferSelect)
        registerBufferKeybind(bufferId, "ins escape", switchBufferEscape)
        registerBufferInputHook(bufferId, switchBufferInputUpdated)
    }

    switchBufferClearInput()
    switchBufferUpdateResults()
    setActiveBuffer(tableGet(switchBuffer, "id"))
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space b", createSwitchBuffer)

############

# Workspace Search

fn workspaceSearchDependenciesAvailable() {
    return commandExists("rg")
}

fn workspaceSearchDependenciesError() {
    infoModalOpen("Workspace Search requires `rg` (ripgrep) to be installed and available in PATH.")
}

workspaceSearch = createTable()
tableSet(workspaceSearch, "id", -1)
tableSet(workspaceSearch, "input", "")
tableSet(workspaceSearch, "results", createArray())
tableSet(workspaceSearch, "selected", 0)
tableSet(workspaceSearch, "previous_buffer_id", -1)

fn workspaceSearchDisplay(entry) {
    return tableGet(entry, "display")
}

fn renderWorkspaceSearch() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ” Workspace Search")
    tableSet(ctx, "input_header", "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(workspaceSearch, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(workspaceSearch, "results"))
    tableSet(ctx, "selected_index", tableGet(workspaceSearch, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No matches")
    tableSet(ctx, "buffer_id", tableGet(workspaceSearch, "id"))
    tableSet(ctx, "entry_to_string", workspaceSearchDisplay)
    listPanelRender(ctx)
}

fn workspaceSearchClearInput() {
    inputClear(tableGet(workspaceSearch, "id"), workspaceSearch, "input", null)
}

fn workspaceSearchBackspace() {
    inputBackspace(tableGet(workspaceSearch, "id"), workspaceSearch, "input", null)
}

fn workspaceSearchUpdateResults() {
    tableSet(workspaceSearch, "results", createArray())
    if stringLen(tableGet(workspaceSearch, "input")) <= 1 {
        tableSet(workspaceSearch, "selected", 0)
        renderWorkspaceSearch()
        return null
    }

    results = runShellCommand("rg --json --color=never --smart-case --max-count 100 \"" + tableGet(workspaceSearch, "input") + "\"", getWorkspaceDir())
    lines = stringSplitLines(tableGet(results, "stdout"))
    entries = createArray()

    i = 0
    loop {
        if i >= arrayLen(lines) { break }
        line = arrayGet(lines, i)
        if line != "" {
            rgResult = fromJson(line)
            if tableGet(rgResult, "type") == "match" {
                data = tableGet(rgResult, "data")
                filePath = tableGet(tableGet(data, "path"), "text")
                row = tableGet(data, "line_number") - 1
                lineText = tableGet(tableGet(data, "lines"), "text")
                lineParts = stringSplitLines(lineText)
                if arrayLen(lineParts) > 0 {
                    lineText = arrayGet(lineParts, 0)
                }
                submatches = tableGet(data, "submatches")
                j = 0
                loop {
                    if j >= arrayLen(submatches) { break }
                    submatch = arrayGet(submatches, j)
                    start = tableGet(submatch, "start")
                    end = tableGet(submatch, "end")

                    display = filePath + ":" + toJson(row) + ":" + toJson(start) + " " + lineText

                    entry = createTable()
                    tableSet(entry, "file_path", filePath)
                    tableSet(entry, "row", row)
                    tableSet(entry, "start", start)
                    tableSet(entry, "end", end)
                    tableSet(entry, "display", display)
                    arrayPushBack(entries, entry)
                    j = j + 1
                }
            }
        }
        i = i + 1
    }
    tableSet(workspaceSearch, "results", entries)
    tableSet(workspaceSearch, "selected", 0)
    renderWorkspaceSearch()
}

fn workspaceSearchInputUpdated() {
    inputUpdated(tableGet(workspaceSearch, "id"), workspaceSearch, "input", workspaceSearchUpdateResults)
}

fn workspaceSearchAddSpace() {
    inputAddSpace(tableGet(workspaceSearch, "id"), workspaceSearch, "input", renderWorkspaceSearch)
}

fn workspaceSearchMoveSelection(delta) {
    results = tableGet(workspaceSearch, "results")
    selected = listPanelMoveSelection(results, tableGet(workspaceSearch, "selected"), delta)
    tableSet(workspaceSearch, "selected", selected)
    renderWorkspaceSearch()
}

fn workspaceSearchNext() {
    workspaceSearchMoveSelection(1)
}

fn workspaceSearchPrevious() {
    workspaceSearchMoveSelection(-1)
}

fn workspaceSearchSelect() {
    results = tableGet(workspaceSearch, "results")
    selected = tableGet(workspaceSearch, "selected")
    if selected < arrayLen(results) {
        selection = arrayGet(results, selected)
        path = tableGet(selection, "file_path")
        row = tableGet(selection, "row")
        start = tableGet(selection, "start")
        end = tableGet(selection, "end")

        range = createTable()
        cursor = createTable()
        mark = createTable()

        tableSet(mark, "row", row)
        tableSet(mark, "column", start)
        tableSet(cursor, "row", row)
        tableSet(cursor, "column", end)
        tableSet(range, "cursor", cursor)
        tableSet(range, "mark", mark)

        workspaceSearchClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceSearchEscape() {
    previousBufferId = tableGet(workspaceSearch, "previous_buffer_id")
    if previousBufferId != -1 {
        workspaceSearchClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createWorkspaceSearch() {
    if !workspaceSearchDependenciesAvailable() {
        workspaceSearchDependenciesError()
        return null
    }
    tableSet(workspaceSearch, "previous_buffer_id", getActiveBuffer())
    if tableGet(workspaceSearch, "id") == -1 {
        bufferId = createSpecialBuffer("Workspace Search")
        tableSet(workspaceSearch, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", workspaceSearchAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceSearchBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins down", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins up", workspaceSearchPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceSearchSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceSearchEscape)
        registerBufferInputHook(bufferId, workspaceSearchInputUpdated)
    }
    workspaceSearchClearInput()
    setActiveBuffer(tableGet(workspaceSearch, "id"))
    workspaceSearchUpdateResults()
    runAction("enter-insert-mode")
}

############

# Workspace Diagnostics

workspaceDiagnostics = createTable()
tableSet(workspaceDiagnostics, "id", -1)
tableSet(workspaceDiagnostics, "input", "")
tableSet(workspaceDiagnostics, "all", createArray())
tableSet(workspaceDiagnostics, "results", createArray())
tableSet(workspaceDiagnostics, "selected", 0)
tableSet(workspaceDiagnostics, "previous_buffer_id", -1)

fn workspaceDiagnosticsDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    severity = tableGet(entry, "severity")
    source = tableGet(entry, "source")
    code = tableGet(entry, "code")
    message = tableGet(entry, "message")

    if source == "null" { source = "" }
    if code == "null" { code = "" }

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    details = source
    if stringLen(code) > 0 {
        details = details + " " + code
    }

    if stringLen(details) > 0 {
        return "[" + severity + "] " + location + " (" + details + ") " + message
    }

    return "[" + severity + "] " + location + " " + message
}

fn renderWorkspaceDiagnostics() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ©º Diagnostics")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(workspaceDiagnostics, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(workspaceDiagnostics, "results"))
    tableSet(ctx, "selected_index", tableGet(workspaceDiagnostics, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No diagnostics")
    tableSet(ctx, "buffer_id", tableGet(workspaceDiagnostics, "id"))
    tableSet(ctx, "entry_to_string", workspaceDiagnosticsDisplay)
    listPanelRender(ctx)
}

fn workspaceDiagnosticsFilterResults() {
    results = createArray()
    query = stringToLower(tableGet(workspaceDiagnostics, "input"))
    allEntries = tableGet(workspaceDiagnostics, "all")

    i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        entry = arrayGet(allEntries, i)

        message = stringToLower(tableGet(entry, "message"))
        filePath = stringToLower(tableGet(entry, "file_path"))
        severity = stringToLower(tableGet(entry, "severity"))
        source = stringToLower(tableGet(entry, "source"))

        if stringLen(query) == 0 or stringContains(message, query) or stringContains(filePath, query) or stringContains(severity, query) or stringContains(source, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(workspaceDiagnostics, "results", results)
    tableSet(workspaceDiagnostics, "selected", 0)
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsInputUpdated() {
    inputUpdated(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", workspaceDiagnosticsFilterResults)
}

fn workspaceDiagnosticsAddSpace() {
    inputAddSpace(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", renderWorkspaceDiagnostics)
}

fn workspaceDiagnosticsBackspace() {
    inputBackspace(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsClearInput() {
    inputClear(tableGet(workspaceDiagnostics, "id"), workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsMoveSelection(delta) {
    results = tableGet(workspaceDiagnostics, "results")
    selected = listPanelMoveSelection(results, tableGet(workspaceDiagnostics, "selected"), delta)
    tableSet(workspaceDiagnostics, "selected", selected)
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsNext() {
    workspaceDiagnosticsMoveSelection(1)
}

fn workspaceDiagnosticsPrevious() {
    workspaceDiagnosticsMoveSelection(-1)
}

fn workspaceDiagnosticsSelect() {
    results = tableGet(workspaceDiagnostics, "results")
    selected = tableGet(workspaceDiagnostics, "selected")
    if selected < arrayLen(results) {
        entry = arrayGet(results, selected)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        workspaceDiagnosticsClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceDiagnosticsEscape() {
    previousBufferId = tableGet(workspaceDiagnostics, "previous_buffer_id")
    if previousBufferId != -1 {
        workspaceDiagnosticsClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn workspaceDiagnosticsReload() {
    diagnostics = getWorkspaceDiagnostics()
    tableSet(workspaceDiagnostics, "all", fromJson(diagnostics))
    workspaceDiagnosticsFilterResults()
}

fn createWorkspaceDiagnostics() {
    tableSet(workspaceDiagnostics, "previous_buffer_id", getActiveBuffer())
    if tableGet(workspaceDiagnostics, "id") == -1 {
        bufferId = createSpecialBuffer("Workspace Diagnostics")
        tableSet(workspaceDiagnostics, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", workspaceDiagnosticsAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceDiagnosticsBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins down", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins up", workspaceDiagnosticsPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceDiagnosticsSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceDiagnosticsEscape)
        registerBufferInputHook(bufferId, workspaceDiagnosticsInputUpdated)
    }
    workspaceDiagnosticsClearInput()
    workspaceDiagnosticsReload()
    setActiveBuffer(tableGet(workspaceDiagnostics, "id"))
    runAction("enter-insert-mode")
}

############

# Command Dispatcher

commandDispatcher = createTable()
tableSet(commandDispatcher, "id", -1)
tableSet(commandDispatcher, "input", "")
tableSet(commandDispatcher, "all", createArray())
tableSet(commandDispatcher, "results", createArray())
tableSet(commandDispatcher, "selected", 0)
tableSet(commandDispatcher, "previous_buffer_id", -1)

fn renderCommandDispatcher() {
    ctx = createTable()
    tableSet(ctx, "title", "âš¡ Command Palette")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(commandDispatcher, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(commandDispatcher, "results"))
    tableSet(ctx, "selected_index", tableGet(commandDispatcher, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No commands")
    tableSet(ctx, "buffer_id", tableGet(commandDispatcher, "id"))
    listPanelRender(ctx)
}

fn commandDispatcherFilterResults() {
    results = createArray()
    query = stringToLower(tableGet(commandDispatcher, "input"))
    allActions = tableGet(commandDispatcher, "all")

    i = 0
    loop {
        if i >= arrayLen(allActions) { break }
        action = arrayGet(allActions, i)
        actionLower = stringToLower(action)

        if stringLen(query) == 0 or stringContains(actionLower, query) {
            arrayPushBack(results, action)
        }
        i = i + 1
    }

    tableSet(commandDispatcher, "results", results)
    tableSet(commandDispatcher, "selected", 0)
    renderCommandDispatcher()
}

fn commandDispatcherInputUpdated() {
    inputUpdated(tableGet(commandDispatcher, "id"), commandDispatcher, "input", commandDispatcherFilterResults)
}

fn commandDispatcherAddSpace() {
    inputAddSpace(tableGet(commandDispatcher, "id"), commandDispatcher, "input", renderCommandDispatcher)
}

fn commandDispatcherBackspace() {
    inputBackspace(tableGet(commandDispatcher, "id"), commandDispatcher, "input", null)
}

fn commandDispatcherClearInput() {
    inputClear(tableGet(commandDispatcher, "id"), commandDispatcher, "input", null)
}

fn commandDispatcherMoveSelection(delta) {
    results = tableGet(commandDispatcher, "results")
    selected = listPanelMoveSelection(results, tableGet(commandDispatcher, "selected"), delta)
    tableSet(commandDispatcher, "selected", selected)
    renderCommandDispatcher()
}

fn commandDispatcherNext() {
    commandDispatcherMoveSelection(1)
}

fn commandDispatcherPrevious() {
    commandDispatcherMoveSelection(-1)
}

fn commandDispatcherSelect() {
    results = tableGet(commandDispatcher, "results")
    selected = tableGet(commandDispatcher, "selected")
    if selected < arrayLen(results) {
        action = arrayGet(results, selected)
        previousBufferId = tableGet(commandDispatcher, "previous_buffer_id")
        commandDispatcherClearInput()
        if previousBufferId != -1 {
            setActiveBuffer(previousBufferId)
        }
        runAction("quit-insert-mode")
        runAction(action)
    }
}

fn commandDispatcherEscape() {
    previousBufferId = tableGet(commandDispatcher, "previous_buffer_id")
    if previousBufferId != -1 {
        commandDispatcherClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn commandDispatcherReload() {
    actions = getActions()
    tableSet(commandDispatcher, "all", fromJson(actions))
    commandDispatcherFilterResults()
}

fn createCommandDispatcher() {
    tableSet(commandDispatcher, "previous_buffer_id", getActiveBuffer())
    if tableGet(commandDispatcher, "id") == -1 {
        bufferId = createSpecialBuffer("Command Dispatcher")
        tableSet(commandDispatcher, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", commandDispatcherAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", commandDispatcherBackspace)
        registerBufferKeybind(bufferId, "ins tab", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins down", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins up", commandDispatcherPrevious)
        registerBufferKeybind(bufferId, "ins enter", commandDispatcherSelect)
        registerBufferKeybind(bufferId, "ins escape", commandDispatcherEscape)
        registerBufferInputHook(bufferId, commandDispatcherInputUpdated)
    }
    commandDispatcherClearInput()
    commandDispatcherReload()
    setActiveBuffer(tableGet(commandDispatcher, "id"))
    runAction("enter-insert-mode")
}

############

# Go To Definition

goToDefinition = createTable()
tableSet(goToDefinition, "id", -1)
tableSet(goToDefinition, "input", "")
tableSet(goToDefinition, "all", createArray())
tableSet(goToDefinition, "results", createArray())
tableSet(goToDefinition, "selected", 0)
tableSet(goToDefinition, "previous_buffer_id", -1)

fn goToDefinitionDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    preview = tableGet(entry, "preview")

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToDefinition() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ“Œ Definitions")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(goToDefinition, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(goToDefinition, "results"))
    tableSet(ctx, "selected_index", tableGet(goToDefinition, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No definitions")
    tableSet(ctx, "buffer_id", tableGet(goToDefinition, "id"))
    tableSet(ctx, "entry_to_string", goToDefinitionDisplay)
    listPanelRender(ctx)
}

fn goToDefinitionFilterResults() {
    results = createArray()
    query = stringToLower(tableGet(goToDefinition, "input"))
    allEntries = tableGet(goToDefinition, "all")

    i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        entry = arrayGet(allEntries, i)

        filePath = stringToLower(tableGet(entry, "file_path"))
        preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(goToDefinition, "results", results)
    tableSet(goToDefinition, "selected", 0)
    renderGoToDefinition()
}

fn goToDefinitionInputUpdated() {
    inputUpdated(tableGet(goToDefinition, "id"), goToDefinition, "input", goToDefinitionFilterResults)
}

fn goToDefinitionAddSpace() {
    inputAddSpace(tableGet(goToDefinition, "id"), goToDefinition, "input", renderGoToDefinition)
}

fn goToDefinitionBackspace() {
    inputBackspace(tableGet(goToDefinition, "id"), goToDefinition, "input", null)
}

fn goToDefinitionClearInput() {
    inputClear(tableGet(goToDefinition, "id"), goToDefinition, "input", null)
}

fn goToDefinitionMoveSelection(delta) {
    results = tableGet(goToDefinition, "results")
    selected = listPanelMoveSelection(results, tableGet(goToDefinition, "selected"), delta)
    tableSet(goToDefinition, "selected", selected)
    renderGoToDefinition()
}

fn goToDefinitionNext() {
    goToDefinitionMoveSelection(1)
}

fn goToDefinitionPrevious() {
    goToDefinitionMoveSelection(-1)
}

fn goToDefinitionSelect() {
    results = tableGet(goToDefinition, "results")
    selected = tableGet(goToDefinition, "selected")
    if selected < arrayLen(results) {
        entry = arrayGet(results, selected)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        goToDefinitionClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToDefinitionEscape() {
    previousBufferId = tableGet(goToDefinition, "previous_buffer_id")
    if previousBufferId != -1 {
        goToDefinitionClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToDefinitionReload() {
    definitions = getDefinitions()
    tableSet(goToDefinition, "all", fromJson(definitions))
    goToDefinitionFilterResults()
}

fn createGoToDefinition() {
    tableSet(goToDefinition, "previous_buffer_id", getActiveBuffer())
    if tableGet(goToDefinition, "id") == -1 {
        bufferId = createSpecialBuffer("Definitions")
        tableSet(goToDefinition, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", goToDefinitionAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToDefinitionBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins down", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins up", goToDefinitionPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToDefinitionSelect)
        registerBufferKeybind(bufferId, "ins escape", goToDefinitionEscape)
        registerBufferInputHook(bufferId, goToDefinitionInputUpdated)
    }
    goToDefinitionClearInput()
    goToDefinitionReload()
    setActiveBuffer(tableGet(goToDefinition, "id"))
    runAction("enter-insert-mode")
}

# Go To References

goToReferences = createTable()
tableSet(goToReferences, "id", -1)
tableSet(goToReferences, "input", "")
tableSet(goToReferences, "all", createArray())
tableSet(goToReferences, "results", createArray())
tableSet(goToReferences, "selected", 0)
tableSet(goToReferences, "previous_buffer_id", -1)

fn goToReferencesDisplay(entry) {
    filePath = tableGet(entry, "file_path")
    range = tableGet(entry, "range")
    mark = tableGet(range, "mark")
    row = tableGet(mark, "row") + 1
    column = tableGet(mark, "column") + 1
    preview = tableGet(entry, "preview")

    location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToReferences() {
    ctx = createTable()
    tableSet(ctx, "title", "ðŸ”— References")
    tableSet(ctx, "input_header", "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "input_value", tableGet(goToReferences, "input"))
    tableSet(ctx, "list_header", "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    tableSet(ctx, "entries", tableGet(goToReferences, "results"))
    tableSet(ctx, "selected_index", tableGet(goToReferences, "selected"))
    tableSet(ctx, "reserved_lines", 5)
    tableSet(ctx, "empty_text", "No references")
    tableSet(ctx, "buffer_id", tableGet(goToReferences, "id"))
    tableSet(ctx, "entry_to_string", goToReferencesDisplay)
    listPanelRender(ctx)
}

fn goToReferencesFilterResults() {
    results = createArray()
    query = stringToLower(tableGet(goToReferences, "input"))
    allEntries = tableGet(goToReferences, "all")

    i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        entry = arrayGet(allEntries, i)

        filePath = stringToLower(tableGet(entry, "file_path"))
        preview = stringToLower(tableGet(entry, "preview"))

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    tableSet(goToReferences, "results", results)
    tableSet(goToReferences, "selected", 0)
    renderGoToReferences()
}

fn goToReferencesInputUpdated() {
    inputUpdated(tableGet(goToReferences, "id"), goToReferences, "input", goToReferencesFilterResults)
}

fn goToReferencesAddSpace() {
    inputAddSpace(tableGet(goToReferences, "id"), goToReferences, "input", renderGoToReferences)
}

fn goToReferencesBackspace() {
    inputBackspace(tableGet(goToReferences, "id"), goToReferences, "input", null)
}

fn goToReferencesClearInput() {
    inputClear(tableGet(goToReferences, "id"), goToReferences, "input", null)
}

fn goToReferencesMoveSelection(delta) {
    results = tableGet(goToReferences, "results")
    selected = listPanelMoveSelection(results, tableGet(goToReferences, "selected"), delta)
    tableSet(goToReferences, "selected", selected)
    renderGoToReferences()
}

fn goToReferencesNext() {
    goToReferencesMoveSelection(1)
}

fn goToReferencesPrevious() {
    goToReferencesMoveSelection(-1)
}

fn goToReferencesSelect() {
    results = tableGet(goToReferences, "results")
    selected = tableGet(goToReferences, "selected")
    if selected < arrayLen(results) {
        entry = arrayGet(results, selected)
        path = tableGet(entry, "file_path")
        range = tableGet(entry, "range")

        goToReferencesClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToReferencesEscape() {
    previousBufferId = tableGet(goToReferences, "previous_buffer_id")
    if previousBufferId != -1 {
        goToReferencesClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToReferencesReload() {
    references = getReferences()
    tableSet(goToReferences, "all", fromJson(references))
    goToReferencesFilterResults()
}

fn createGoToReferences() {
    tableSet(goToReferences, "previous_buffer_id", getActiveBuffer())
    if tableGet(goToReferences, "id") == -1 {
        bufferId = createSpecialBuffer("References")
        tableSet(goToReferences, "id", bufferId)
        registerBufferKeybind(bufferId, "ins space", goToReferencesAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToReferencesBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins down", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins up", goToReferencesPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToReferencesSelect)
        registerBufferKeybind(bufferId, "ins escape", goToReferencesEscape)
        registerBufferInputHook(bufferId, goToReferencesInputUpdated)
    }
    goToReferencesClearInput()
    goToReferencesReload()
    setActiveBuffer(tableGet(goToReferences, "id"))
    runAction("enter-insert-mode")
}

############

# Dialog Modal

dialogModal = createTable()
tableSet(dialogModal, "id", -1)
tableSet(dialogModal, "previous_buffer_id", -1)
tableSet(dialogModal, "active", false)
tableSet(dialogModal, "input", "")
tableSet(dialogModal, "prompt", "")
tableSet(dialogModal, "callback", null)

fn setSearchQueryFromDialog(query) {
    setSearchQuery(query)
    runAction("find-next-with-query")
}

fn dialogModalRender() {
    content = "ðŸ’¬ Dialog\n" + tableGet(dialogModal, "prompt") + "\nâ•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" + tableGet(dialogModal, "input") + "\n\nenter: submit | esc: cancel"
    setViewportBufferContent(tableGet(dialogModal, "id"), content)
}

fn dialogModalEnsureBuffer() {
    if tableGet(dialogModal, "id") == -1 {
        bufferId = createSpecialBuffer("Dialog")
        tableSet(dialogModal, "id", bufferId)
        registerBufferKeybind(bufferId, "ins enter", dialogModalSubmit)
        registerBufferKeybind(bufferId, "ins escape", dialogModalClose)
        registerBufferKeybind(bufferId, "ins backspace", dialogModalBackspace)
        registerBufferKeybind(bufferId, "ins space", dialogModalInsertSpace)
        registerBufferInputHook(bufferId, dialogModalInputUpdated)
    }
}

fn dialogModalOpen(prompt, callback) {
    dialogModalEnsureBuffer()
    tableSet(dialogModal, "previous_buffer_id", getActiveBuffer())
    tableSet(dialogModal, "active", true)
    tableSet(dialogModal, "prompt", prompt)
    tableSet(dialogModal, "callback", callback)
    tableSet(dialogModal, "input", "")

    bufferId = tableGet(dialogModal, "id")
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    dialogModalRender()
    runAction("enter-insert-mode")
}

fn dialogModalClose() {
    tableSet(dialogModal, "active", false)
    tableSet(dialogModal, "input", "")
    tableSet(dialogModal, "prompt", "")
    tableSet(dialogModal, "callback", null)
    previousBufferId = tableGet(dialogModal, "previous_buffer_id")
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn dialogModalSubmit() {
    if !tableGet(dialogModal, "active") { return null }
    value = getBufferInput(tableGet(dialogModal, "id"))
    callback = tableGet(dialogModal, "callback")
    dialogModalClose()
    if callback != null {
        callback(value)
    }
}

fn dialogModalInputUpdated() {
    inputUpdated(tableGet(dialogModal, "id"), dialogModal, "input", dialogModalRender)
}

fn dialogModalInsertSpace() {
    inputAddSpace(tableGet(dialogModal, "id"), dialogModal, "input", dialogModalRender)
}

fn dialogModalBackspace() {
    inputValue = getBufferInput(tableGet(dialogModal, "id"))
    length = stringLen(inputValue)
    if length <= 0 { return null }
    inputValue = stringTruncateWidth(inputValue, length - 1)
    tableSet(dialogModal, "input", inputValue)
    setBufferInput(tableGet(dialogModal, "id"), inputValue)
    dialogModalRender()
}

############

# Info Modal

infoModal = createTable()
tableSet(infoModal, "id", -1)
tableSet(infoModal, "previous_buffer_id", -1)
tableSet(infoModal, "content", "")
tableSet(infoModal, "scroll", 0)
tableSet(infoModal, "active", false)
tableSet(infoModal, "page_size", 48)

fn infoModalClampScroll(totalLines, pageSize) {
    maxScroll = totalLines - pageSize
    if maxScroll < 0 { maxScroll = 0 }
    infoModalScroll = tableGet(infoModal, "scroll")
    if infoModalScroll < 0 { infoModalScroll = 0 }
    if infoModalScroll > maxScroll { infoModalScroll = maxScroll }
    tableSet(infoModal, "scroll", infoModalScroll)
}

fn infoModalRender() {
    content = "Info Modal (esc to close, up/down to scroll)\n------"
    infoModalContent = tableGet(infoModal, "content")
    columns = viewportVisibleColumns()
    wrappedAll = stringRenderViewport(infoModalContent, columns, 100000, 0)
    wrappedLines = stringSplitLines(wrappedAll)
    totalLines = arrayLen(wrappedLines)

    if totalLines == 0 {
        content = content + "\n\n   No information available"
        setViewportBufferContent(tableGet(infoModal, "id"), content)
        return null
    }

    visibleRows = viewportVisibleRows(0)
    bodyRows = visibleRows - 3
    if bodyRows < 1 { bodyRows = 1 }

    footerLines = 0
    if tableGet(infoModal, "scroll") + bodyRows < totalLines and bodyRows > 2 {
        footerLines = 2
        bodyRows = bodyRows - footerLines
    }

    tableSet(infoModal, "page_size", bodyRows)
    infoModalClampScroll(totalLines, bodyRows)

    scroll = tableGet(infoModal, "scroll")
    body = stringRenderViewport(infoModalContent, columns, bodyRows, scroll)
    content = content + "\n\n" + body

    remaining = totalLines - (scroll + bodyRows)
    if remaining > 0 {
        content = content + "\n\n... (" + toJson(remaining) + " more lines)"
    }

    setViewportBufferContent(tableGet(infoModal, "id"), content)
}

fn infoModalEnsureBuffer() {
    if tableGet(infoModal, "id") == -1 {
        bufferId = createSpecialBuffer("Info")
        tableSet(infoModal, "id", bufferId)
        registerBufferKeybind(bufferId, "ins escape", infoModalClose)
        registerBufferKeybind(bufferId, "ins up", infoModalScrollUp)
        registerBufferKeybind(bufferId, "ins down", infoModalScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", infoModalPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", infoModalPageDown)
    }
}

fn infoModalOpen(content) {
    infoModalEnsureBuffer()
    if !tableGet(infoModal, "active") {
        tableSet(infoModal, "previous_buffer_id", getActiveBuffer())
    }
    tableSet(infoModal, "active", true)
    tableSet(infoModal, "content", content)
    tableSet(infoModal, "scroll", 0)
    infoModalRender()
    bufferId = tableGet(infoModal, "id")
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    runAction("enter-insert-mode")
}

fn infoModalClose() {
    tableSet(infoModal, "active", false)
    tableSet(infoModal, "scroll", 0)
    previousBufferId = tableGet(infoModal, "previous_buffer_id")
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn infoModalScrollUp() {
    if !tableGet(infoModal, "active") { return null }
    infoModalScroll = tableGet(infoModal, "scroll") - 1
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalScrollDown() {
    if !tableGet(infoModal, "active") { return null }
    infoModalScroll = tableGet(infoModal, "scroll") + 1
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalPageUp() {
    if !tableGet(infoModal, "active") { return null }
    infoModalScroll = tableGet(infoModal, "scroll") - tableGet(infoModal, "page_size")
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

fn infoModalPageDown() {
    if !tableGet(infoModal, "active") { return null }
    infoModalScroll = tableGet(infoModal, "scroll") + tableGet(infoModal, "page_size")
    tableSet(infoModal, "scroll", infoModalScroll)
    infoModalRender()
}

##############

fn rerenderAllUi() {
    renderDashboard()

    if tableGet(llmChat, "id") != -1 { renderLLMChat() }
    if tableGet(fuzzyFileFinder, "id") != -1 { renderFuzzyFileFinder() }
    if tableGet(switchBuffer, "id") != -1 { renderSwitchBuffer() }
    if tableGet(workspaceSearch, "id") != -1 { renderWorkspaceSearch() }
    if tableGet(workspaceDiagnostics, "id") != -1 { renderWorkspaceDiagnostics() }
    if tableGet(commandDispatcher, "id") != -1 { renderCommandDispatcher() }
    if tableGet(goToDefinition, "id") != -1 { renderGoToDefinition() }
    if tableGet(goToReferences, "id") != -1 { renderGoToReferences() }
    if tableGet(dialogModal, "active") { dialogModalRender() }
    if tableGet(infoModal, "active") { infoModalRender() }
}

createDashboardBuffer()
refreshViewportSize()
runAction("set-init-rsl-complete")
