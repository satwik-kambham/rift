# Callbacks

fn onViewportSizeChanged(rows, columns) {
    setViewportSize(rows, columns)
}

# UI Helper Methods

fn setViewportSize(rows, columns) {
    viewportRows = rows
    viewportColumns = columns
    rerenderAllUi()
}

fn refreshViewportSize() {
    let size = fromJson(getViewportSize())
    setViewportSize(size["rows"], size["columns"])
}

fn viewportVisibleRows(reservedLines) {
    # Keep a reasonable default even if the viewport has not reported yet.
    let available = viewportRows - reservedLines
    if available < 5 { available = 5 }
    return available
}

fn viewportVisibleColumns() {
    # Rendering reserves 3 columns (see RopeBuffer::get_visible_lines); clamp to visible width.
    let columns = viewportColumns
    if columns <= 0 { columns = 20 }
    columns = columns - 3
    if columns < 1 { columns = 1 }
    return columns
}

fn clampLineToViewport(line, columns) {
    if columns <= 0 { return "" }
    if stringWidth(line) <= columns { return line }

    let ellipsis = "â€¦"
    let ellipsisWidth = stringWidth(ellipsis)

    if ellipsisWidth >= columns { return stringTruncateWidth(ellipsis, columns) }

    let available = columns - ellipsisWidth
    if available < 0 { available = 0 }
    return stringTruncateWidth(line, available) + ellipsis
}

fn clampContentToViewport(content) {
    let columns = viewportVisibleColumns()
    let lines = stringSplitLines(content)
    let clamped = ""

    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = lines[i]
        let clampedLine = clampLineToViewport(line, columns)
        if i > 0 { clamped = clamped + "\n" }
        clamped = clamped + clampedLine
        i = i + 1
    }

    return clamped
}

fn setViewportBufferContent(bufferId, content) {
    setBufferContent(bufferId, clampContentToViewport(content))
}

fn viewportWindow(selectedIndex, totalItems, reservedLines) {
    let window = createTable()
    if totalItems <= 0 {
        window["start"] = 0
        window["end"] = 0
        return window
    }

    let visible = viewportVisibleRows(reservedLines)
    if visible > totalItems { visible = totalItems }

    let start = floor(selectedIndex - (visible / 2))
    if start < 0 { start = 0 }
    let end = start + visible
    if end > totalItems {
        end = totalItems
        start = end - visible
        if start < 0 { start = 0 }
    }

    window["start"] = start
    window["end"] = end
    return window
}

# Shared List + Input Helpers

fn listPanelMoveSelection(entries, selectedIndex, delta) {
    let total = arrayLen(entries)
    if total == 0 { return 0 }
    let nextIndex = selectedIndex + delta
    if nextIndex < 0 { nextIndex = total - 1 }
    if nextIndex >= total { nextIndex = 0 }
    return nextIndex
}

fn listPanelRender(ctx) {
    let title = ctx["title"]
    let inputHeader = ctx["input_header"]
    let inputValue = ctx["input_value"]
    let listHeader = ctx["list_header"]
    let entries = ctx["entries"]
    let selectedIndex = ctx["selected_index"]
    let reservedLines = ctx["reserved_lines"]
    let emptyText = ctx["empty_text"]
    let bufferId = ctx["buffer_id"]
    let entryToString = ctx["entry_to_string"]
    let headerLines = ctx["header_lines"]
    let extraLines = ctx["extra_lines"]

    let content = title
    if headerLines != null {
        let i = 0
        loop {
            if i >= arrayLen(headerLines) { break }
            content = content + "\n" + headerLines[i]
            i = i + 1
        }
    }

    content = content + "\n" + inputHeader + "\n" + inputValue + "\n" + listHeader

    if extraLines != null {
        let i = 0
        loop {
            if i >= arrayLen(extraLines) { break }
            content = content + "\n" + extraLines[i]
            i = i + 1
        }
    }

    let total = arrayLen(entries)
    if total == 0 {
        content = content + "\n   " + emptyText
        setViewportBufferContent(bufferId, content)
        return null
    }

    if reservedLines == null { reservedLines = 5 }
    let window = viewportWindow(selectedIndex, total, reservedLines)
    let start = window["start"]
    let end = window["end"]

    if start > 0 { content = content + "\n   â‹¯" }

    let i = start
    loop {
        if i >= end { break }
        let entry = entries[i]
        let display = entry
        if entryToString != null {
            display = entryToString(entry)
        }
        let prefix = "â€¢"
        if selectedIndex == i { prefix = "âž¤" }
        content = content + "\n " + prefix + " " + display
        i = i + 1
    }

    if end < total { content = content + "\n   â‹¯" }

    setViewportBufferContent(bufferId, content)
}

fn inputGet(bufferId) {
    return getBufferInput(bufferId)
}

fn inputSet(bufferId, value) {
    setBufferInput(bufferId, value)
}

fn inputUpdated(bufferId, stateTable, key, onUpdated) {
    let value = getBufferInput(bufferId)
    stateTable[key] = value
    if onUpdated != null { onUpdated() }
}

fn inputAddSpace(bufferId, stateTable, key, onUpdated) {
    let value = getBufferInput(bufferId)
    value = value + " "
    stateTable[key] = value
    setBufferInput(bufferId, value)
    if onUpdated != null { onUpdated() }
}

fn inputBackspace(bufferId, stateTable, key, onCleared) {
    let value = getBufferInput(bufferId)
    let length = stringLen(value)
    if length <= 0 { return null }
    value = stringTruncateWidth(value, length - 1)
    stateTable[key] = value
    setBufferInput(bufferId, value)
    if onCleared != null { onCleared() }
}

fn inputClear(bufferId, stateTable, key, onCleared) {
    stateTable[key] = ""
    setBufferInput(bufferId, "")
    if onCleared != null { onCleared() }
}

# Dashboard

let viewportRows = 0
let viewportColumns = 0
let dashboard = createTable()
dashboard["id"] = -1
dashboard["text"] = "
Welcome to rift!

Basic Keybinds:

esc - Quit Insert Mode
i - Enter Insert Mode
space q - Quit
space f - Fuzzy File Picker (with fd & fzf)
space F - File Explorer
space b - Switch Buffer
"

fn renderDashboard() {
    let dashboardId = dashboard["id"]
    if dashboardId == -1 { return null }
    let content = dashboard["text"] + "\nViewport: " + toString(viewportRows) + " x " + toString(viewportColumns)
    setViewportBufferContent(dashboardId, content)
}

fn createDashboardBuffer() {
    let dashboardId = dashboard["id"]
    if dashboardId == -1 {
        let bufferId = createSpecialBuffer("Dashboard")
        dashboard["id"] = bufferId
        let activeBuffer = getActiveBuffer()
        if activeBuffer == null {
            setActiveBuffer(bufferId)
        }
    }
    renderDashboard()
}

#################

# Agentic Chat

fn toolDeclarations() {
    return
"[
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"run_shell_command\",
            \"description\": \"Run a shell command and return the output\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"command\": {\"type\": \"string\"}
                },
                \"required\": [\"command\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"find_file\",
            \"description\": \"Returns paths matching regex pattern by searching recursively in the workspace folder, returning absolute paths. Does not accept glob patterns.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"search_workspace\",
            \"description\": \"Grep search in the current workspace for matching patterns\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"pattern\": {\"type\": \"string\"}
                },
                \"required\": [\"pattern\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"read_file\",
            \"description\": \"Get the content of a file with line numbers\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"path\": {\"type\": \"string\"}
                },
                \"required\": [\"path\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"write_file\",
            \"description\": \"Writes content to a specified file replacing the existing content.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"content\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"content\"]
            }
        }
    },
    {
        \"type\": \"function\",
        \"function\": {
            \"name\": \"replace\",
            \"description\": \"Replaces text within a file. Can replace single or multiple occurrences.\",
            \"parameters\": {
                \"type\": \"object\",
                \"properties\": {
                    \"file_path\": {\"type\": \"string\"},
                    \"old_string\": {\"type\": \"string\"},
                    \"new_string\": {\"type\": \"string\"}
                },
                \"required\": [\"file_path\", \"old_string\", \"new_string\"]
            }
        }
    }
]"
}

fn agentRunShellCommand(command) {
    let outputs = runShellCommand(command, getWorkspaceDir())
    return "STDOUT:\n" + outputs["stdout"] + "\nSTDERR:\n" + outputs["stderr"]
}

fn agentFindFile(pattern) {
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path " + pattern, getWorkspaceDir())
    return results["stdout"]
}

fn agentSearchWorkspace(pattern) {
    let results = runShellCommand("rg " + pattern, getWorkspaceDir())
    return results["stdout"]
}

fn getOpenRouterProvider() {
    let provider = createTable()
    provider["url"] = "https://openrouter.ai/api/v1/chat/completions"
    provider["api_key"] = getEnvVar("OPENROUTER_KEY")
    provider["model"] = "mistralai/devstral-small"
    return provider
}

fn getLlamaCppProvider() {
    let provider = createTable()
    provider["url"] = "http://127.0.0.1:8080/v1/chat/completions"
    provider["api_key"] = null
    provider["model"] = "Granite-4.0-H-Tiny"
    return provider
}

let openRouterProvider = getOpenRouterProvider()
let llamaCppProvider = getLlamaCppProvider()

let llmChat = createTable()
llmChat["id"] = -1
llmChat["provider"] = llamaCppProvider
llmChat["history_scroll"] = 0
llmChat["history_page_size"] = 1
llmChat["input"] = ""
llmChat["history"] = createArray()
llmChat["pending_tool_calls"] = createArray()

fn llmChatRoleLabel(message) {
    let role = message["role"]
    let label = role
    if role == "assistant" { label = "Assistant" }
    if role == "user" { label = "User" }
    if role == "system" { label = "System" }
    if role == "tool" {
        label = "Tool"
        let name = message["name"]
        if name != null {
            label = "Tool (" + name + ")"
        }
    }
    return label
}

fn llmChatToolCallName(toolCall) {
    let toolFunc = toolCall["function"]
    if toolFunc == null { return "unknown" }
    let name = toolFunc["name"]
    if name == null { return "unknown" }
    return name
}

fn llmChatLinesToString(lines) {
    let text = ""
    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = lines[i]
        if i > 0 { text = text + "\n" }
        text = text + line
        i = i + 1
    }
    return text
}

fn llmChatScrollUp() {
    let llmChatHistoryScroll = llmChat["history_scroll"] + 1
    llmChat["history_scroll"] = llmChatHistoryScroll
    renderLLMChat()
}

fn llmChatScrollDown() {
    let llmChatHistoryScroll = llmChat["history_scroll"] - 1
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    llmChat["history_scroll"] = llmChatHistoryScroll
    renderLLMChat()
}

fn llmChatPageUp() {
    let llmChatHistoryScroll = llmChat["history_scroll"] + llmChat["history_page_size"]
    llmChat["history_scroll"] = llmChatHistoryScroll
    renderLLMChat()
}

fn llmChatPageDown() {
    let llmChatHistoryScroll = llmChat["history_scroll"] - llmChat["history_page_size"]
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    llmChat["history_scroll"] = llmChatHistoryScroll
    renderLLMChat()
}

fn renderLLMChat() {
    let chatHistory = llmChat["history"]
    let historyLines = createArray()
    let totalMessages = arrayLen(chatHistory)
    let i = 0
    loop {
        if i >= totalMessages { break }
        let message = chatHistory[i]
        let label = llmChatRoleLabel(message)
        arrayPushBack(historyLines, label + ":")
        let content = message["content"]
        if content == null { content = "" }
        let contentLines = stringSplitLines(content)
        if arrayLen(contentLines) == 0 or stringLen(content) == 0 {
            arrayPushBack(historyLines, "  (empty)")
        }
        if arrayLen(contentLines) != 0 and stringLen(content) != 0 {
            let j = 0
            loop {
                if j >= arrayLen(contentLines) { break }
                let line = contentLines[j]
                arrayPushBack(historyLines, "  " + line)
                j = j + 1
            }
        }
        let toolCalls = message["tool_calls"]
        if toolCalls != null {
            let j = 0
            loop {
                if j >= arrayLen(toolCalls) { break }
                let toolCall = toolCalls[j]
                let toolName = llmChatToolCallName(toolCall)
                arrayPushBack(historyLines, "  â€¢ tool call: " + toolName)
                j = j + 1
            }
        }
        if i < totalMessages - 1 {
            arrayPushBack(historyLines, "")
        }
        i = i + 1
    }

    let historyContent = ""
    if arrayLen(historyLines) == 0 {
        historyContent = "   No messages yet"
    }
    if arrayLen(historyLines) != 0 {
        historyContent = llmChatLinesToString(historyLines)
    }

    let pendingToolCalls = llmChat["pending_tool_calls"]
    let pendingLines = createArray()
    if arrayLen(pendingToolCalls) == 0 {
        arrayPushBack(pendingLines, "   None")
    }
    if arrayLen(pendingToolCalls) != 0 {
        let i = 0
        loop {
            if i >= arrayLen(pendingToolCalls) { break }
            let toolCall = pendingToolCalls[i]
            let toolName = llmChatToolCallName(toolCall)
            arrayPushBack(pendingLines, " â€¢ " + toolName)
            i = i + 1
        }
    }

    let chatInput = llmChat["input"]
    let inputLines = stringSplitLines(chatInput)
    if arrayLen(inputLines) == 0 or stringLen(chatInput) == 0 {
        inputLines = createArray()
        arrayPushBack(inputLines, "Type a message...")
    }

    let headerLines = 3
    let sectionLines = 3
    let reservedLines = headerLines + sectionLines + arrayLen(pendingLines) + arrayLen(inputLines)
    let historyRows = viewportVisibleRows(reservedLines)
    if historyRows < 1 { historyRows = 1 }

    let columns = viewportVisibleColumns()
    let wrappedAll = stringRenderViewport(historyContent, columns, 100000, 0)
    let wrappedLines = stringSplitLines(wrappedAll)
    let totalHistoryLines = arrayLen(wrappedLines)
    if totalHistoryLines < 1 { totalHistoryLines = 1 }

    let llmChatHistoryScroll = llmChat["history_scroll"]
    let showEllipsis = llmChatHistoryScroll > 0
    if showEllipsis and historyRows <= 1 { showEllipsis = false }
    if showEllipsis { historyRows = historyRows - 1 }

    let maxScroll = totalHistoryLines - historyRows
    if maxScroll < 0 { maxScroll = 0 }
    if llmChatHistoryScroll < 0 { llmChatHistoryScroll = 0 }
    if llmChatHistoryScroll > maxScroll { llmChatHistoryScroll = maxScroll }
    llmChat["history_scroll"] = llmChatHistoryScroll
    llmChat["history_page_size"] = historyRows

    let historyBody = stringRenderViewport(historyContent, columns, historyRows, -1 * (llmChatHistoryScroll + 1))
    let provider = llmChat["provider"]
    let modelName = "unknown"
    if provider != null { modelName = provider["model"] }
    let status = "Model: " + modelName + " | Pending tools: " + toString(arrayLen(pendingToolCalls))

    let content = "ðŸ¤– LLM Chat\n" + status + "\nenter: send | y/n: allow/deny tool | up/down: scroll\n"
    content = content + "â•­â”€ History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    if showEllipsis { content = content + "   â‹¯\n" }
    content = content + historyBody + "\n"
    content = content + "â•°â”€ Pending Tools â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(pendingLines) + "\n"
    content = content + "â•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    content = content + llmChatLinesToString(inputLines)

    setViewportBufferContent(llmChat["id"], content)
}

fn requestChatCompletion() {
    let provider = llmChat["provider"]
    if provider == null { return null }

    let apiKey = provider["api_key"]
    let modelName = provider["model"]
    let url = provider["url"]

    let request = createTable()
    request["model"] = modelName
    request["messages"] = llmChat["history"]
    request["tools"] = fromJson(toolDeclarations())
    request["stream"] = false
    request["temperature"] = 0.3
    request["seed"] = 42

    let body = toJson(request)
    let hasApiKey = apiKey != null and stringLen(apiKey) != 0
    let response = null
    if hasApiKey { response = postRequestWithBearerToken(url, body, apiKey) }
    if !hasApiKey { response = postRequest(url, body) }
    response = fromJson(response)
    let message = response["choices"][0]["message"]
    let toolCalls = message["tool_calls"]
    
    if toolCalls != null {
        let pendingToolCalls = llmChat["pending_tool_calls"]
        let i = arrayLen(toolCalls)
        loop {
            if i <= 0 { break }
            let toolCall = toolCalls[i - 1]
            
            arrayPushBack(pendingToolCalls, toolCall)
            
            let toolName = toolCall["function"]["name"]
            let toolArgs = fromJson(toolCall["function"]["arguments"])
            let toolCallId = toolCall["id"]
            
            i = i - 1
        }
    }
    
    arrayPushBack(llmChat["history"], message)

    renderLLMChat()
}

fn getToolCallResult(allowed) {
    let pendingToolCalls = llmChat["pending_tool_calls"]
    let toolCall = arrayPopBack(pendingToolCalls)
    
    let toolName = toolCall["function"]["name"]
    let toolArgs = fromJson(toolCall["function"]["arguments"])
    let toolCallId = toolCall["id"]
    
    let result = "Tool call request denied by user. Await further instructions."
    
    if allowed {
        if toolName == "run_shell_command" {
            result = agentRunShellCommand(toolArgs["command"])
        }
        if toolName == "find_file" {
            result = agentFindFile(toolArgs["pattern"])
        }
        if toolName == "search_workspace" {
            result = agentSearchWorkspace(toolArgs["pattern"])
        }
        if toolName == "read_file" {
            result = agentReadFile(getWorkspaceDir(), toolArgs["path"])
        }
        if toolName == "write_file" {
            result = agentFindFile(getWorkspaceDir(), toolArgs["file_path"], toolArgs["content"])
        }
        if toolName == "replace" {
            result = agentFindFile(getWorkspaceDir(), toolArgs["file_path"], toolArgs["old_string"], toolArgs["new_string"])
        }
    }
    
    let message = createTable()
    message["role"] = "tool"
    message["content"] = result
    message["name"] = toolName
    message["tool_call_id"] = toolCallId
    arrayPushBack(llmChat["history"], message)
    
    renderLLMChat()

    if arrayLen(pendingToolCalls) == 0 {
        requestChatCompletion()
    }
}

fn allowToolCall() { getToolCallResult(true) }
fn denyToolCall() { getToolCallResult(false) }

fn sendMessage() {
    let pendingToolCalls = llmChat["pending_tool_calls"]
    if arrayLen(pendingToolCalls) == 0 {
        let message = createTable()
        message["role"] = "user"
        message["content"] = llmChat["input"]
        arrayPushBack(llmChat["history"], message)

        llmChatClearInput()
        renderLLMChat()
    
        requestChatCompletion()
    }
}

fn llmChatInputUpdated() {
    inputUpdated(llmChat["id"], llmChat, "input", renderLLMChat)
}

fn llmChatAddSpace() {
    inputAddSpace(llmChat["id"], llmChat, "input", renderLLMChat)
}

fn llmChatBackspace() {
    inputBackspace(llmChat["id"], llmChat, "input", renderLLMChat)
}

fn llmChatClearInput() {
    inputClear(llmChat["id"], llmChat, "input", null)
}

fn createLLMChat() {
    if llmChat["id"] == -1 {
        let bufferId = createSpecialBuffer("LLM Chat")
        llmChat["id"] = bufferId
        registerBufferKeybind(bufferId, "ins enter", sendMessage)
        registerBufferKeybind(bufferId, "nor up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "nor down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "nor pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "nor pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "ins space", llmChatAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", llmChatBackspace)
        registerBufferKeybind(bufferId, "ins up", llmChatScrollUp)
        registerBufferKeybind(bufferId, "ins down", llmChatScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", llmChatPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", llmChatPageDown)
        registerBufferKeybind(bufferId, "nor y", allowToolCall)
        registerBufferKeybind(bufferId, "nor n", denyToolCall)
        registerBufferInputHook(bufferId, llmChatInputUpdated)
        renderLLMChat()
    }
    setActiveBuffer(llmChat["id"])
}

registerGlobalKeybind("nor space c", createLLMChat)

############

# Fuzzy Find File

fn fuzzyFileFinderDependenciesAvailable() {
    return commandExists("fd") and commandExists("fzf")
}

fn fuzzyFileFinderDependenciesError() {
    infoModalOpen("Fuzzy File Finder requires `fd` and `fzf` to be installed and available in PATH.")
}

let fuzzyFileFinder = createTable()
fuzzyFileFinder["id"] = -1
fuzzyFileFinder["input"] = ""
fuzzyFileFinder["results"] = createArray()
fuzzyFileFinder["selected"] = 0
fuzzyFileFinder["previous_buffer_id"] = -1

fn renderFuzzyFileFinder() {
    let ctx = createTable()
    ctx["title"] = "ðŸ”Ž Fuzzy File Finder"
    ctx["input_header"] = "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = fuzzyFileFinder["input"]
    ctx["list_header"] = "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = fuzzyFileFinder["results"]
    ctx["selected_index"] = fuzzyFileFinder["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No files found"
    ctx["buffer_id"] = fuzzyFileFinder["id"]
    listPanelRender(ctx)
}

fn fuzzyFileFinderWorkspaceEntries() {
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path", getWorkspaceDir())
    fuzzyFileFinder["results"] = stringSplitLines(results["stdout"])
    fuzzyFileFinder["selected"] = 0
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderInputUpdated() {
    inputUpdated(fuzzyFileFinder["id"], fuzzyFileFinder, "input", null)
    let results = runShellCommand("fd --type f --strip-cwd-prefix --full-path --absolute-path | fzf -f \"" + fuzzyFileFinder["input"] + "\"", getWorkspaceDir())
    fuzzyFileFinder["results"] = stringSplitLines(results["stdout"])
    fuzzyFileFinder["selected"] = 0
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderAddSpace() {
    inputAddSpace(fuzzyFileFinder["id"], fuzzyFileFinder, "input", renderFuzzyFileFinder)
}

fn fuzzyFileFinderBackspace() {
    inputBackspace(fuzzyFileFinder["id"], fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderClearInput() {
    inputClear(fuzzyFileFinder["id"], fuzzyFileFinder, "input", null)
}

fn fuzzyFileFinderMoveSelection(delta) {
    let results = fuzzyFileFinder["results"]
    let selected = listPanelMoveSelection(results, fuzzyFileFinder["selected"], delta)
    fuzzyFileFinder["selected"] = selected
    renderFuzzyFileFinder()
}

fn fuzzyFileFinderNext() {
    fuzzyFileFinderMoveSelection(1)
}

fn fuzzyFileFinderPrevious() {
    fuzzyFileFinderMoveSelection(-1)
}

fn fuzzyFileFinderSelect() {
    let results = fuzzyFileFinder["results"]
    let selected = fuzzyFileFinder["selected"]
    if selected < arrayLen(results) {
        let path = results[selected]
        fuzzyFileFinderClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fuzzyFileFinderEscape() {
    let previousBufferId = fuzzyFileFinder["previous_buffer_id"]
    if previousBufferId != -1 {
        fuzzyFileFinderClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createFuzzyFileFinder() {
    if !fuzzyFileFinderDependenciesAvailable() {
        fuzzyFileFinderDependenciesError()
        return null
    }
    fuzzyFileFinder["previous_buffer_id"] = getActiveBuffer()
    if fuzzyFileFinder["id"] == -1 {
        let bufferId = createSpecialBuffer("Fuzzy File Finder")
        fuzzyFileFinder["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", fuzzyFileFinderAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fuzzyFileFinderBackspace)
        registerBufferKeybind(bufferId, "ins tab", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins down", fuzzyFileFinderNext)
        registerBufferKeybind(bufferId, "ins up", fuzzyFileFinderPrevious)
        registerBufferKeybind(bufferId, "ins enter", fuzzyFileFinderSelect)
        registerBufferKeybind(bufferId, "ins escape", fuzzyFileFinderEscape)
        registerBufferInputHook(bufferId, fuzzyFileFinderInputUpdated)
    }
    fuzzyFileFinderClearInput()
    setActiveBuffer(fuzzyFileFinder["id"])
    fuzzyFileFinderWorkspaceEntries()
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space f", createFuzzyFileFinder)

############

# File Explorer

let fileExplorer = createTable()
fileExplorer["id"] = -1
fileExplorer["input"] = ""
fileExplorer["entries"] = createArray()
fileExplorer["all_entries"] = createArray()
fileExplorer["selected"] = 0
fileExplorer["current_dir"] = ""
fileExplorer["previous_buffer_id"] = -1
fileExplorer["error"] = ""

fn fileExplorerEntryDisplay(entry) {
    let name = entry["name"]
    if entry["is_dir"] {
        return name + "/"
    }
    return name
}

fn renderFileExplorer() {
    let headerLines = createArray()
    arrayPushBack(headerLines, fileExplorer["current_dir"])
    arrayPushBack(headerLines, "(ctrl-f: new file, ctrl-d: new folder)")

    let extraLines = null
    let errorMessage = fileExplorer["error"]
    if errorMessage != "" {
        extraLines = createArray()
        arrayPushBack(extraLines, "   Error: " + errorMessage)
    }

    let ctx = createTable()
    ctx["title"] = "ðŸ“‚ File Explorer"
    ctx["header_lines"] = headerLines
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = fileExplorer["input"]
    ctx["list_header"] = "â•°â”€ Entries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = fileExplorer["entries"]
    ctx["selected_index"] = fileExplorer["selected"]
    ctx["reserved_lines"] = 6
    ctx["empty_text"] = "No entries"
    ctx["buffer_id"] = fileExplorer["id"]
    ctx["entry_to_string"] = fileExplorerEntryDisplay
    ctx["extra_lines"] = extraLines
    listPanelRender(ctx)
}

fn fileExplorerApplyFilter() {
    let query = stringToLower(fileExplorer["input"])
    let entries = createArray()
    let allEntries = fileExplorer["all_entries"]

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = allEntries[i]
        let name = stringToLower(entry["name"])

        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(entries, entry)
        }

        i = i + 1
    }

    fileExplorer["entries"] = entries

    if arrayLen(entries) == 0 {
        fileExplorer["selected"] = 0
    }
    if fileExplorer["selected"] >= arrayLen(entries) {
        fileExplorer["selected"] = 0
    }

    renderFileExplorer()
}

fn fileExplorerRefreshEntries() {
    let listing = listDir(fileExplorer["current_dir"])
    let allEntries = createArray()
    fileExplorer["error"] = ""

    let errorMessage = listing["error"]
    if errorMessage != null {
        fileExplorer["error"] = errorMessage
    }

    let entries = listing["entries"]

    let parentEntry = createTable()
    parentEntry["name"] = ".."
    parentEntry["path"] = parentPath(fileExplorer["current_dir"])
    parentEntry["is_dir"] = true
    arrayPushBack(allEntries, parentEntry)

    let i = 0
    loop {
        if i >= arrayLen(entries) { break }
        let entry = entries[i]
        arrayPushBack(allEntries, entry)
        i = i + 1
    }

    fileExplorer["all_entries"] = allEntries
    fileExplorer["selected"] = 0
    fileExplorerApplyFilter()
}

fn fileExplorerSetDirectory(path) {
    fileExplorer["current_dir"] = path
    fileExplorerRefreshEntries()
}

fn fileExplorerInputUpdated() {
    inputUpdated(fileExplorer["id"], fileExplorer, "input", fileExplorerApplyFilter)
}

fn fileExplorerAddSpace() {
    inputAddSpace(fileExplorer["id"], fileExplorer, "input", renderFileExplorer)
}

fn fileExplorerBackspace() {
    inputBackspace(fileExplorer["id"], fileExplorer, "input", null)
}

fn fileExplorerClearInput() {
    inputClear(fileExplorer["id"], fileExplorer, "input", null)
}

fn fileExplorerMoveSelection(delta) {
    let entries = fileExplorer["entries"]
    let selected = listPanelMoveSelection(entries, fileExplorer["selected"], delta)
    fileExplorer["selected"] = selected
    renderFileExplorer()
}

fn fileExplorerNext() {
    fileExplorerMoveSelection(1)
}

fn fileExplorerPrevious() {
    fileExplorerMoveSelection(-1)
}

fn fileExplorerSelect() {
    let entries = fileExplorer["entries"]
    let selected = fileExplorer["selected"]
    if selected < arrayLen(entries) {
        let entry = entries[selected]
        let path = entry["path"]
        if entry["is_dir"] {
            fileExplorerClearInput()
            fileExplorerSetDirectory(path)
            return null
        }
        fileExplorerClearInput()
        openFile(path)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerEscape() {
    let previousBufferId = fileExplorer["previous_buffer_id"]
    if previousBufferId != -1 {
        fileExplorerClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn fileExplorerCreateFileSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("File name cannot be empty.")
        return null
    }

    let targetPath = joinPath(fileExplorer["current_dir"], pathInput)
    let result = createBlankFile(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerRefreshEntries()
    openFile(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFilePrompt() {
    let prompt = "Create File\n" + fileExplorer["current_dir"] + "\nEnter file name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFileSubmit)
}

fn fileExplorerCreateFolderSubmit(pathInput) {
    if stringLen(pathInput) == 0 {
        infoModalOpen("Folder name cannot be empty.")
        return null
    }

    let targetPath = joinPath(fileExplorer["current_dir"], pathInput)
    let result = createDirectory(targetPath)

    if result != null {
        infoModalOpen(toString(result))
        fileExplorerRefreshEntries()
        return null
    }

    fileExplorerSetDirectory(targetPath)
    runAction("quit-insert-mode")
}

fn fileExplorerCreateFolderPrompt() {
    let prompt = "Create Folder\n" + fileExplorer["current_dir"] + "\nEnter folder name or path:"
    dialogModalOpen(prompt, fileExplorerCreateFolderSubmit)
}

fn createFileExplorer() {
    fileExplorer["previous_buffer_id"] = getActiveBuffer()

    if fileExplorer["id"] == -1 {
        let bufferId = createSpecialBuffer("File Explorer")
        fileExplorer["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", fileExplorerAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", fileExplorerBackspace)
        registerBufferKeybind(bufferId, "ins tab", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins down", fileExplorerNext)
        registerBufferKeybind(bufferId, "ins up", fileExplorerPrevious)
        registerBufferKeybind(bufferId, "ins enter", fileExplorerSelect)
        registerBufferKeybind(bufferId, "ins escape", fileExplorerEscape)
        registerBufferKeybind(bufferId, "ins c-f", fileExplorerCreateFilePrompt)
        registerBufferKeybind(bufferId, "ins c-d", fileExplorerCreateFolderPrompt)
        registerBufferInputHook(bufferId, fileExplorerInputUpdated)
    }

    fileExplorerClearInput()
    fileExplorerSetDirectory(getWorkspaceDir())
    setActiveBuffer(fileExplorer["id"])
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space s-f", createFileExplorer)

############

# Switch Buffer

let switchBuffer = createTable()
switchBuffer["id"] = -1
switchBuffer["input"] = ""
switchBuffer["results"] = createArray()
switchBuffer["buffers"] = createArray()
switchBuffer["selected"] = 0
switchBuffer["selected_id"] = -1
switchBuffer["previous_buffer_id"] = -1
switchBuffer["initial_active_id"] = -1

fn switchBufferDisplay(entry) {
    let display = entry["display_name"]
    if entry["special"] {
        display = "[special] " + display
    }
    if entry["modified"] {
        display = display + " *"
    }
    if entry["is_active"] {
        display = display + " (active)"
    }
    return display
}

fn renderSwitchBuffer() {
    let ctx = createTable()
    ctx["title"] = "ðŸ—‚ Switch Buffer"
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = switchBuffer["input"]
    ctx["list_header"] = "â•°â”€ Buffers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = switchBuffer["results"]
    ctx["selected_index"] = switchBuffer["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No buffers"
    ctx["buffer_id"] = switchBuffer["id"]
    ctx["entry_to_string"] = switchBufferDisplay
    listPanelRender(ctx)
}

fn switchBufferLoadBuffers() {
    let buffers = listBuffers()
    switchBuffer["buffers"] = fromJson(buffers)
}

fn switchBufferUpdateSelectionFromId(targetId) {
    let results = switchBuffer["results"]
    if arrayLen(results) == 0 {
        switchBuffer["selected"] = 0
        switchBuffer["selected_id"] = -1
        renderSwitchBuffer()
        return null
    }

    let selectedEntry = 0
    let i = 0
    loop {
        if i >= arrayLen(results) { break }
        let entry = results[i]
        if entry["id"] == targetId {
            selectedEntry = i
            break
        }
        i = i + 1
    }

    let selectedEntryValue = results[selectedEntry]
    switchBuffer["selected"] = selectedEntry
    switchBuffer["selected_id"] = selectedEntryValue["id"]
    renderSwitchBuffer()
}

fn switchBufferUpdateResults() {
    switchBufferLoadBuffers()

    let previousSelectionId = switchBuffer["selected_id"]
    if previousSelectionId == -1 {
        previousSelectionId = switchBuffer["initial_active_id"]
    }

    let query = stringToLower(switchBuffer["input"])
    let results = createArray()
    let buffers = switchBuffer["buffers"]

    let i = 0
    loop {
        if i >= arrayLen(buffers) { break }
        let entry = buffers[i]
        let name = stringToLower(entry["display_name"])
        if stringLen(query) == 0 or stringContains(name, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    switchBuffer["results"] = results
    switchBuffer["selected_id"] = -1
    switchBuffer["selected"] = 0
    switchBufferUpdateSelectionFromId(previousSelectionId)
}

fn switchBufferInputUpdated() {
    inputUpdated(switchBuffer["id"], switchBuffer, "input", switchBufferUpdateResults)
}

fn switchBufferAddSpace() {
    inputAddSpace(switchBuffer["id"], switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferBackspace() {
    inputBackspace(switchBuffer["id"], switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferClearInput() {
    inputClear(switchBuffer["id"], switchBuffer, "input", renderSwitchBuffer)
}

fn switchBufferMoveSelection(delta) {
    let results = switchBuffer["results"]
    let selected = listPanelMoveSelection(results, switchBuffer["selected"], delta)
    switchBuffer["selected"] = selected
    if arrayLen(results) == 0 {
        switchBuffer["selected_id"] = -1
    }
    if arrayLen(results) != 0 {
        let entry = results[selected]
        switchBuffer["selected_id"] = entry["id"]
    }
    renderSwitchBuffer()
}

fn switchBufferNext() {
    switchBufferMoveSelection(1)
}

fn switchBufferPrevious() {
    switchBufferMoveSelection(-1)
}

fn switchBufferSelect() {
    let results = switchBuffer["results"]
    let selected = switchBuffer["selected"]
    if selected < arrayLen(results) {
        let selection = results[selected]
        let bufferId = selection["id"]
        switchBufferClearInput()
        setActiveBuffer(bufferId)
        runAction("quit-insert-mode")
    }
}

fn switchBufferEscape() {
    let previousBufferId = switchBuffer["previous_buffer_id"]
    if previousBufferId != -1 {
        switchBufferClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createSwitchBuffer() {
    let previousBufferId = getActiveBuffer()
    switchBuffer["previous_buffer_id"] = previousBufferId
    switchBuffer["initial_active_id"] = previousBufferId
    switchBuffer["selected_id"] = -1

    if switchBuffer["id"] == -1 {
        let bufferId = createSpecialBuffer("Switch Buffer")
        switchBuffer["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", switchBufferAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", switchBufferBackspace)
        registerBufferKeybind(bufferId, "ins tab", switchBufferNext)
        registerBufferKeybind(bufferId, "ins down", switchBufferNext)
        registerBufferKeybind(bufferId, "ins up", switchBufferPrevious)
        registerBufferKeybind(bufferId, "ins enter", switchBufferSelect)
        registerBufferKeybind(bufferId, "ins escape", switchBufferEscape)
        registerBufferInputHook(bufferId, switchBufferInputUpdated)
    }

    switchBufferClearInput()
    switchBufferUpdateResults()
    setActiveBuffer(switchBuffer["id"])
    runAction("enter-insert-mode")
}

registerGlobalKeybind("nor space b", createSwitchBuffer)

############

# Workspace Search

fn workspaceSearchDependenciesAvailable() {
    return commandExists("rg")
}

fn workspaceSearchDependenciesError() {
    infoModalOpen("Workspace Search requires `rg` (ripgrep) to be installed and available in PATH.")
}

let workspaceSearch = createTable()
workspaceSearch["id"] = -1
workspaceSearch["input"] = ""
workspaceSearch["results"] = createArray()
workspaceSearch["selected"] = 0
workspaceSearch["previous_buffer_id"] = -1

fn workspaceSearchDisplay(entry) {
    return entry["display"]
}

fn renderWorkspaceSearch() {
    let ctx = createTable()
    ctx["title"] = "ðŸ” Workspace Search"
    ctx["input_header"] = "â•­â”€ Query â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = workspaceSearch["input"]
    ctx["list_header"] = "â•°â”€ Matches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = workspaceSearch["results"]
    ctx["selected_index"] = workspaceSearch["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No matches"
    ctx["buffer_id"] = workspaceSearch["id"]
    ctx["entry_to_string"] = workspaceSearchDisplay
    listPanelRender(ctx)
}

fn workspaceSearchClearInput() {
    inputClear(workspaceSearch["id"], workspaceSearch, "input", null)
}

fn workspaceSearchBackspace() {
    inputBackspace(workspaceSearch["id"], workspaceSearch, "input", null)
}

fn workspaceSearchUpdateResults() {
    workspaceSearch["results"] = createArray()
    if stringLen(workspaceSearch["input"]) <= 1 {
        workspaceSearch["selected"] = 0
        renderWorkspaceSearch()
        return null
    }

    let results = runShellCommand("rg --json --color=never --smart-case --max-count 100 \"" + workspaceSearch["input"] + "\"", getWorkspaceDir())
    let lines = stringSplitLines(results["stdout"])
    let entries = createArray()

    let i = 0
    loop {
        if i >= arrayLen(lines) { break }
        let line = lines[i]
        if line != "" {
            let rgResult = fromJson(line)
            if rgResult["type"] == "match" {
                let data = rgResult["data"]
                let filePath = data["path"]["text"]
                let row = data["line_number"] - 1
                let lineText = data["lines"]["text"]
                let lineParts = stringSplitLines(lineText)
                if arrayLen(lineParts) > 0 {
                    lineText = lineParts[0]
                }
                let submatches = data["submatches"]
                let j = 0
                loop {
                    if j >= arrayLen(submatches) { break }
                    let submatch = submatches[j]
                    let start = submatch["start"]
                    let end = submatch["end"]

                    let display = filePath + ":" + toJson(row) + ":" + toJson(start) + " " + lineText

                    let entry = createTable()
                    entry["file_path"] = filePath
                    entry["row"] = row
                    entry["start"] = start
                    entry["end"] = end
                    entry["display"] = display
                    arrayPushBack(entries, entry)
                    j = j + 1
                }
            }
        }
        i = i + 1
    }
    workspaceSearch["results"] = entries
    workspaceSearch["selected"] = 0
    renderWorkspaceSearch()
}

fn workspaceSearchInputUpdated() {
    inputUpdated(workspaceSearch["id"], workspaceSearch, "input", workspaceSearchUpdateResults)
}

fn workspaceSearchAddSpace() {
    inputAddSpace(workspaceSearch["id"], workspaceSearch, "input", renderWorkspaceSearch)
}

fn workspaceSearchMoveSelection(delta) {
    let results = workspaceSearch["results"]
    let selected = listPanelMoveSelection(results, workspaceSearch["selected"], delta)
    workspaceSearch["selected"] = selected
    renderWorkspaceSearch()
}

fn workspaceSearchNext() {
    workspaceSearchMoveSelection(1)
}

fn workspaceSearchPrevious() {
    workspaceSearchMoveSelection(-1)
}

fn workspaceSearchSelect() {
    let results = workspaceSearch["results"]
    let selected = workspaceSearch["selected"]
    if selected < arrayLen(results) {
        let selection = results[selected]
        let path = selection["file_path"]
        let row = selection["row"]
        let start = selection["start"]
        let end = selection["end"]

        let range = createTable()
        let cursor = createTable()
        let mark = createTable()

        mark["row"] = row
        mark["column"] = start
        cursor["row"] = row
        cursor["column"] = end
        range["cursor"] = cursor
        range["mark"] = mark

        workspaceSearchClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceSearchEscape() {
    let previousBufferId = workspaceSearch["previous_buffer_id"]
    if previousBufferId != -1 {
        workspaceSearchClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn createWorkspaceSearch() {
    if !workspaceSearchDependenciesAvailable() {
        workspaceSearchDependenciesError()
        return null
    }
    workspaceSearch["previous_buffer_id"] = getActiveBuffer()
    if workspaceSearch["id"] == -1 {
        let bufferId = createSpecialBuffer("Workspace Search")
        workspaceSearch["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", workspaceSearchAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceSearchBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins down", workspaceSearchNext)
        registerBufferKeybind(bufferId, "ins up", workspaceSearchPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceSearchSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceSearchEscape)
        registerBufferInputHook(bufferId, workspaceSearchInputUpdated)
    }
    workspaceSearchClearInput()
    setActiveBuffer(workspaceSearch["id"])
    workspaceSearchUpdateResults()
    runAction("enter-insert-mode")
}

############

# Workspace Diagnostics

let workspaceDiagnostics = createTable()
workspaceDiagnostics["id"] = -1
workspaceDiagnostics["input"] = ""
workspaceDiagnostics["all"] = createArray()
workspaceDiagnostics["results"] = createArray()
workspaceDiagnostics["selected"] = 0
workspaceDiagnostics["previous_buffer_id"] = -1

fn workspaceDiagnosticsDisplay(entry) {
    let filePath = entry["file_path"]
    let range = entry["range"]
    let mark = range["mark"]
    let row = mark["row"] + 1
    let column = mark["column"] + 1
    let severity = entry["severity"]
    let source = entry["source"]
    let code = entry["code"]
    let message = entry["message"]

    if source == "null" { source = "" }
    if code == "null" { code = "" }

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    let details = source
    if stringLen(code) > 0 {
        details = details + " " + code
    }

    if stringLen(details) > 0 {
        return "[" + severity + "] " + location + " (" + details + ") " + message
    }

    return "[" + severity + "] " + location + " " + message
}

fn renderWorkspaceDiagnostics() {
    let ctx = createTable()
    ctx["title"] = "ðŸ©º Diagnostics"
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = workspaceDiagnostics["input"]
    ctx["list_header"] = "â•°â”€ Issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = workspaceDiagnostics["results"]
    ctx["selected_index"] = workspaceDiagnostics["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No diagnostics"
    ctx["buffer_id"] = workspaceDiagnostics["id"]
    ctx["entry_to_string"] = workspaceDiagnosticsDisplay
    listPanelRender(ctx)
}

fn workspaceDiagnosticsFilterResults() {
    let results = createArray()
    let query = stringToLower(workspaceDiagnostics["input"])
    let allEntries = workspaceDiagnostics["all"]

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = allEntries[i]

        let message = stringToLower(entry["message"])
        let filePath = stringToLower(entry["file_path"])
        let severity = stringToLower(entry["severity"])
        let source = stringToLower(entry["source"])

        if stringLen(query) == 0 or stringContains(message, query) or stringContains(filePath, query) or stringContains(severity, query) or stringContains(source, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    workspaceDiagnostics["results"] = results
    workspaceDiagnostics["selected"] = 0
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsInputUpdated() {
    inputUpdated(workspaceDiagnostics["id"], workspaceDiagnostics, "input", workspaceDiagnosticsFilterResults)
}

fn workspaceDiagnosticsAddSpace() {
    inputAddSpace(workspaceDiagnostics["id"], workspaceDiagnostics, "input", renderWorkspaceDiagnostics)
}

fn workspaceDiagnosticsBackspace() {
    inputBackspace(workspaceDiagnostics["id"], workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsClearInput() {
    inputClear(workspaceDiagnostics["id"], workspaceDiagnostics, "input", null)
}

fn workspaceDiagnosticsMoveSelection(delta) {
    let results = workspaceDiagnostics["results"]
    let selected = listPanelMoveSelection(results, workspaceDiagnostics["selected"], delta)
    workspaceDiagnostics["selected"] = selected
    renderWorkspaceDiagnostics()
}

fn workspaceDiagnosticsNext() {
    workspaceDiagnosticsMoveSelection(1)
}

fn workspaceDiagnosticsPrevious() {
    workspaceDiagnosticsMoveSelection(-1)
}

fn workspaceDiagnosticsSelect() {
    let results = workspaceDiagnostics["results"]
    let selected = workspaceDiagnostics["selected"]
    if selected < arrayLen(results) {
        let entry = results[selected]
        let path = entry["file_path"]
        let range = entry["range"]

        workspaceDiagnosticsClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn workspaceDiagnosticsEscape() {
    let previousBufferId = workspaceDiagnostics["previous_buffer_id"]
    if previousBufferId != -1 {
        workspaceDiagnosticsClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn workspaceDiagnosticsReload() {
    let diagnostics = getWorkspaceDiagnostics()
    workspaceDiagnostics["all"] = fromJson(diagnostics)
    workspaceDiagnosticsFilterResults()
}

fn createWorkspaceDiagnostics() {
    workspaceDiagnostics["previous_buffer_id"] = getActiveBuffer()
    if workspaceDiagnostics["id"] == -1 {
        let bufferId = createSpecialBuffer("Workspace Diagnostics")
        workspaceDiagnostics["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", workspaceDiagnosticsAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", workspaceDiagnosticsBackspace)
        registerBufferKeybind(bufferId, "ins tab", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins down", workspaceDiagnosticsNext)
        registerBufferKeybind(bufferId, "ins up", workspaceDiagnosticsPrevious)
        registerBufferKeybind(bufferId, "ins enter", workspaceDiagnosticsSelect)
        registerBufferKeybind(bufferId, "ins escape", workspaceDiagnosticsEscape)
        registerBufferInputHook(bufferId, workspaceDiagnosticsInputUpdated)
    }
    workspaceDiagnosticsClearInput()
    workspaceDiagnosticsReload()
    setActiveBuffer(workspaceDiagnostics["id"])
    runAction("enter-insert-mode")
}

############

# Command Dispatcher

let commandDispatcher = createTable()
commandDispatcher["id"] = -1
commandDispatcher["input"] = ""
commandDispatcher["all"] = createArray()
commandDispatcher["results"] = createArray()
commandDispatcher["selected"] = 0
commandDispatcher["previous_buffer_id"] = -1

fn renderCommandDispatcher() {
    let ctx = createTable()
    ctx["title"] = "âš¡ Command Palette"
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = commandDispatcher["input"]
    ctx["list_header"] = "â•°â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = commandDispatcher["results"]
    ctx["selected_index"] = commandDispatcher["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No commands"
    ctx["buffer_id"] = commandDispatcher["id"]
    listPanelRender(ctx)
}

fn commandDispatcherFilterResults() {
    let results = createArray()
    let query = stringToLower(commandDispatcher["input"])
    let allActions = commandDispatcher["all"]

    let i = 0
    loop {
        if i >= arrayLen(allActions) { break }
        let action = allActions[i]
        let actionLower = stringToLower(action)

        if stringLen(query) == 0 or stringContains(actionLower, query) {
            arrayPushBack(results, action)
        }
        i = i + 1
    }

    commandDispatcher["results"] = results
    commandDispatcher["selected"] = 0
    renderCommandDispatcher()
}

fn commandDispatcherInputUpdated() {
    inputUpdated(commandDispatcher["id"], commandDispatcher, "input", commandDispatcherFilterResults)
}

fn commandDispatcherAddSpace() {
    inputAddSpace(commandDispatcher["id"], commandDispatcher, "input", renderCommandDispatcher)
}

fn commandDispatcherBackspace() {
    inputBackspace(commandDispatcher["id"], commandDispatcher, "input", null)
}

fn commandDispatcherClearInput() {
    inputClear(commandDispatcher["id"], commandDispatcher, "input", null)
}

fn commandDispatcherMoveSelection(delta) {
    let results = commandDispatcher["results"]
    let selected = listPanelMoveSelection(results, commandDispatcher["selected"], delta)
    commandDispatcher["selected"] = selected
    renderCommandDispatcher()
}

fn commandDispatcherNext() {
    commandDispatcherMoveSelection(1)
}

fn commandDispatcherPrevious() {
    commandDispatcherMoveSelection(-1)
}

fn commandDispatcherSelect() {
    let results = commandDispatcher["results"]
    let selected = commandDispatcher["selected"]
    if selected < arrayLen(results) {
        let action = results[selected]
        let previousBufferId = commandDispatcher["previous_buffer_id"]
        commandDispatcherClearInput()
        if previousBufferId != -1 {
            setActiveBuffer(previousBufferId)
        }
        runAction("quit-insert-mode")
        runAction(action)
    }
}

fn commandDispatcherEscape() {
    let previousBufferId = commandDispatcher["previous_buffer_id"]
    if previousBufferId != -1 {
        commandDispatcherClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn commandDispatcherReload() {
    let actions = getActions()
    commandDispatcher["all"] = fromJson(actions)
    commandDispatcherFilterResults()
}

fn createCommandDispatcher() {
    commandDispatcher["previous_buffer_id"] = getActiveBuffer()
    if commandDispatcher["id"] == -1 {
        let bufferId = createSpecialBuffer("Command Dispatcher")
        commandDispatcher["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", commandDispatcherAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", commandDispatcherBackspace)
        registerBufferKeybind(bufferId, "ins tab", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins down", commandDispatcherNext)
        registerBufferKeybind(bufferId, "ins up", commandDispatcherPrevious)
        registerBufferKeybind(bufferId, "ins enter", commandDispatcherSelect)
        registerBufferKeybind(bufferId, "ins escape", commandDispatcherEscape)
        registerBufferInputHook(bufferId, commandDispatcherInputUpdated)
    }
    commandDispatcherClearInput()
    commandDispatcherReload()
    setActiveBuffer(commandDispatcher["id"])
    runAction("enter-insert-mode")
}

############

# Go To Definition

let goToDefinition = createTable()
goToDefinition["id"] = -1
goToDefinition["input"] = ""
goToDefinition["all"] = createArray()
goToDefinition["results"] = createArray()
goToDefinition["selected"] = 0
goToDefinition["previous_buffer_id"] = -1

fn goToDefinitionDisplay(entry) {
    let filePath = entry["file_path"]
    let range = entry["range"]
    let mark = range["mark"]
    let row = mark["row"] + 1
    let column = mark["column"] + 1
    let preview = entry["preview"]

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToDefinition() {
    let ctx = createTable()
    ctx["title"] = "ðŸ“Œ Definitions"
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = goToDefinition["input"]
    ctx["list_header"] = "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = goToDefinition["results"]
    ctx["selected_index"] = goToDefinition["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No definitions"
    ctx["buffer_id"] = goToDefinition["id"]
    ctx["entry_to_string"] = goToDefinitionDisplay
    listPanelRender(ctx)
}

fn goToDefinitionFilterResults() {
    let results = createArray()
    let query = stringToLower(goToDefinition["input"])
    let allEntries = goToDefinition["all"]

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = allEntries[i]

        let filePath = stringToLower(entry["file_path"])
        let preview = stringToLower(entry["preview"])

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    goToDefinition["results"] = results
    goToDefinition["selected"] = 0
    renderGoToDefinition()
}

fn goToDefinitionInputUpdated() {
    inputUpdated(goToDefinition["id"], goToDefinition, "input", goToDefinitionFilterResults)
}

fn goToDefinitionAddSpace() {
    inputAddSpace(goToDefinition["id"], goToDefinition, "input", renderGoToDefinition)
}

fn goToDefinitionBackspace() {
    inputBackspace(goToDefinition["id"], goToDefinition, "input", null)
}

fn goToDefinitionClearInput() {
    inputClear(goToDefinition["id"], goToDefinition, "input", null)
}

fn goToDefinitionMoveSelection(delta) {
    let results = goToDefinition["results"]
    let selected = listPanelMoveSelection(results, goToDefinition["selected"], delta)
    goToDefinition["selected"] = selected
    renderGoToDefinition()
}

fn goToDefinitionNext() {
    goToDefinitionMoveSelection(1)
}

fn goToDefinitionPrevious() {
    goToDefinitionMoveSelection(-1)
}

fn goToDefinitionSelect() {
    let results = goToDefinition["results"]
    let selected = goToDefinition["selected"]
    if selected < arrayLen(results) {
        let entry = results[selected]
        let path = entry["file_path"]
        let range = entry["range"]

        goToDefinitionClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToDefinitionEscape() {
    let previousBufferId = goToDefinition["previous_buffer_id"]
    if previousBufferId != -1 {
        goToDefinitionClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToDefinitionReload() {
    let definitions = getDefinitions()
    goToDefinition["all"] = fromJson(definitions)
    goToDefinitionFilterResults()
}

fn createGoToDefinition() {
    goToDefinition["previous_buffer_id"] = getActiveBuffer()
    if goToDefinition["id"] == -1 {
        let bufferId = createSpecialBuffer("Definitions")
        goToDefinition["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", goToDefinitionAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToDefinitionBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins down", goToDefinitionNext)
        registerBufferKeybind(bufferId, "ins up", goToDefinitionPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToDefinitionSelect)
        registerBufferKeybind(bufferId, "ins escape", goToDefinitionEscape)
        registerBufferInputHook(bufferId, goToDefinitionInputUpdated)
    }
    goToDefinitionClearInput()
    goToDefinitionReload()
    setActiveBuffer(goToDefinition["id"])
    runAction("enter-insert-mode")
}

# Go To References

let goToReferences = createTable()
goToReferences["id"] = -1
goToReferences["input"] = ""
goToReferences["all"] = createArray()
goToReferences["results"] = createArray()
goToReferences["selected"] = 0
goToReferences["previous_buffer_id"] = -1

fn goToReferencesDisplay(entry) {
    let filePath = entry["file_path"]
    let range = entry["range"]
    let mark = range["mark"]
    let row = mark["row"] + 1
    let column = mark["column"] + 1
    let preview = entry["preview"]

    let location = filePath + ":" + toJson(row) + ":" + toJson(column)
    if stringLen(preview) > 0 {
        return location + " " + preview
    }
    return location
}

fn renderGoToReferences() {
    let ctx = createTable()
    ctx["title"] = "ðŸ”— References"
    ctx["input_header"] = "â•­â”€ Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["input_value"] = goToReferences["input"]
    ctx["list_header"] = "â•°â”€ Locations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    ctx["entries"] = goToReferences["results"]
    ctx["selected_index"] = goToReferences["selected"]
    ctx["reserved_lines"] = 5
    ctx["empty_text"] = "No references"
    ctx["buffer_id"] = goToReferences["id"]
    ctx["entry_to_string"] = goToReferencesDisplay
    listPanelRender(ctx)
}

fn goToReferencesFilterResults() {
    let results = createArray()
    let query = stringToLower(goToReferences["input"])
    let allEntries = goToReferences["all"]

    let i = 0
    loop {
        if i >= arrayLen(allEntries) { break }
        let entry = allEntries[i]

        let filePath = stringToLower(entry["file_path"])
        let preview = stringToLower(entry["preview"])

        if stringLen(query) == 0 or stringContains(filePath, query) or stringContains(preview, query) {
            arrayPushBack(results, entry)
        }
        i = i + 1
    }

    goToReferences["results"] = results
    goToReferences["selected"] = 0
    renderGoToReferences()
}

fn goToReferencesInputUpdated() {
    inputUpdated(goToReferences["id"], goToReferences, "input", goToReferencesFilterResults)
}

fn goToReferencesAddSpace() {
    inputAddSpace(goToReferences["id"], goToReferences, "input", renderGoToReferences)
}

fn goToReferencesBackspace() {
    inputBackspace(goToReferences["id"], goToReferences, "input", null)
}

fn goToReferencesClearInput() {
    inputClear(goToReferences["id"], goToReferences, "input", null)
}

fn goToReferencesMoveSelection(delta) {
    let results = goToReferences["results"]
    let selected = listPanelMoveSelection(results, goToReferences["selected"], delta)
    goToReferences["selected"] = selected
    renderGoToReferences()
}

fn goToReferencesNext() {
    goToReferencesMoveSelection(1)
}

fn goToReferencesPrevious() {
    goToReferencesMoveSelection(-1)
}

fn goToReferencesSelect() {
    let results = goToReferences["results"]
    let selected = goToReferences["selected"]
    if selected < arrayLen(results) {
        let entry = results[selected]
        let path = entry["file_path"]
        let range = entry["range"]

        goToReferencesClearInput()
        openFile(path)
        runAction("quit-insert-mode")
        selectRange(toJson(range))
    }
}

fn goToReferencesEscape() {
    let previousBufferId = goToReferences["previous_buffer_id"]
    if previousBufferId != -1 {
        goToReferencesClearInput()
        setActiveBuffer(previousBufferId)
        runAction("quit-insert-mode")
    }
}

fn goToReferencesReload() {
    let references = getReferences()
    goToReferences["all"] = fromJson(references)
    goToReferencesFilterResults()
}

fn createGoToReferences() {
    goToReferences["previous_buffer_id"] = getActiveBuffer()
    if goToReferences["id"] == -1 {
        let bufferId = createSpecialBuffer("References")
        goToReferences["id"] = bufferId
        registerBufferKeybind(bufferId, "ins space", goToReferencesAddSpace)
        registerBufferKeybind(bufferId, "ins backspace", goToReferencesBackspace)
        registerBufferKeybind(bufferId, "ins tab", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins down", goToReferencesNext)
        registerBufferKeybind(bufferId, "ins up", goToReferencesPrevious)
        registerBufferKeybind(bufferId, "ins enter", goToReferencesSelect)
        registerBufferKeybind(bufferId, "ins escape", goToReferencesEscape)
        registerBufferInputHook(bufferId, goToReferencesInputUpdated)
    }
    goToReferencesClearInput()
    goToReferencesReload()
    setActiveBuffer(goToReferences["id"])
    runAction("enter-insert-mode")
}

############

# Dialog Modal

let dialogModal = createTable()
dialogModal["id"] = -1
dialogModal["previous_buffer_id"] = -1
dialogModal["active"] = false
dialogModal["input"] = ""
dialogModal["prompt"] = ""
dialogModal["callback"] = null

fn setSearchQueryFromDialog(query) {
    setSearchQuery(query)
    runAction("find-next-with-query")
}

fn dialogModalRender() {
    let content = "ðŸ’¬ Dialog\n" + dialogModal["prompt"] + "\nâ•­â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n" + dialogModal["input"] + "\n\nenter: submit | esc: cancel"
    setViewportBufferContent(dialogModal["id"], content)
}

fn dialogModalEnsureBuffer() {
    if dialogModal["id"] == -1 {
        let bufferId = createSpecialBuffer("Dialog")
        dialogModal["id"] = bufferId
        registerBufferKeybind(bufferId, "ins enter", dialogModalSubmit)
        registerBufferKeybind(bufferId, "ins escape", dialogModalClose)
        registerBufferKeybind(bufferId, "ins backspace", dialogModalBackspace)
        registerBufferKeybind(bufferId, "ins space", dialogModalInsertSpace)
        registerBufferInputHook(bufferId, dialogModalInputUpdated)
    }
}

fn dialogModalOpen(prompt, callback) {
    dialogModalEnsureBuffer()
    dialogModal["previous_buffer_id"] = getActiveBuffer()
    dialogModal["active"] = true
    dialogModal["prompt"] = prompt
    dialogModal["callback"] = callback
    dialogModal["input"] = ""

    let bufferId = dialogModal["id"]
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    dialogModalRender()
    runAction("enter-insert-mode")
}

fn dialogModalClose() {
    dialogModal["active"] = false
    dialogModal["input"] = ""
    dialogModal["prompt"] = ""
    dialogModal["callback"] = null
    let previousBufferId = dialogModal["previous_buffer_id"]
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn dialogModalSubmit() {
    if !dialogModal["active"] { return null }
    let value = getBufferInput(dialogModal["id"])
    let callback = dialogModal["callback"]
    dialogModalClose()
    if callback != null {
        callback(value)
    }
}

fn dialogModalInputUpdated() {
    inputUpdated(dialogModal["id"], dialogModal, "input", dialogModalRender)
}

fn dialogModalInsertSpace() {
    inputAddSpace(dialogModal["id"], dialogModal, "input", dialogModalRender)
}

fn dialogModalBackspace() {
    let inputValue = getBufferInput(dialogModal["id"])
    let length = stringLen(inputValue)
    if length <= 0 { return null }
    inputValue = stringTruncateWidth(inputValue, length - 1)
    dialogModal["input"] = inputValue
    setBufferInput(dialogModal["id"], inputValue)
    dialogModalRender()
}

############

# Info Modal

let infoModal = createTable()
infoModal["id"] = -1
infoModal["previous_buffer_id"] = -1
infoModal["content"] = ""
infoModal["scroll"] = 0
infoModal["active"] = false
infoModal["page_size"] = 48

fn infoModalClampScroll(totalLines, pageSize) {
    let maxScroll = totalLines - pageSize
    if maxScroll < 0 { maxScroll = 0 }
    let infoModalScroll = infoModal["scroll"]
    if infoModalScroll < 0 { infoModalScroll = 0 }
    if infoModalScroll > maxScroll { infoModalScroll = maxScroll }
    infoModal["scroll"] = infoModalScroll
}

fn infoModalRender() {
    let content = "Info Modal (esc to close, up/down to scroll)\n------"
    let infoModalContent = infoModal["content"]
    let columns = viewportVisibleColumns()
    let wrappedAll = stringRenderViewport(infoModalContent, columns, 100000, 0)
    let wrappedLines = stringSplitLines(wrappedAll)
    let totalLines = arrayLen(wrappedLines)

    if totalLines == 0 {
        content = content + "\n\n   No information available"
        setViewportBufferContent(infoModal["id"], content)
        return null
    }

    let visibleRows = viewportVisibleRows(0)
    let bodyRows = visibleRows - 3
    if bodyRows < 1 { bodyRows = 1 }

    let footerLines = 0
    if infoModal["scroll"] + bodyRows < totalLines and bodyRows > 2 {
        footerLines = 2
        bodyRows = bodyRows - footerLines
    }

    infoModal["page_size"] = bodyRows
    infoModalClampScroll(totalLines, bodyRows)

    let scroll = infoModal["scroll"]
    let body = stringRenderViewport(infoModalContent, columns, bodyRows, scroll)
    content = content + "\n\n" + body

    let remaining = totalLines - (scroll + bodyRows)
    if remaining > 0 {
        content = content + "\n\n... (" + toJson(remaining) + " more lines)"
    }

    setViewportBufferContent(infoModal["id"], content)
}

fn infoModalEnsureBuffer() {
    if infoModal["id"] == -1 {
        let bufferId = createSpecialBuffer("Info")
        infoModal["id"] = bufferId
        registerBufferKeybind(bufferId, "ins escape", infoModalClose)
        registerBufferKeybind(bufferId, "ins up", infoModalScrollUp)
        registerBufferKeybind(bufferId, "ins down", infoModalScrollDown)
        registerBufferKeybind(bufferId, "ins pageup", infoModalPageUp)
        registerBufferKeybind(bufferId, "ins pagedown", infoModalPageDown)
    }
}

fn infoModalOpen(content) {
    infoModalEnsureBuffer()
    if !infoModal["active"] {
        infoModal["previous_buffer_id"] = getActiveBuffer()
    }
    infoModal["active"] = true
    infoModal["content"] = content
    infoModal["scroll"] = 0
    infoModalRender()
    let bufferId = infoModal["id"]
    setActiveBuffer(bufferId)
    setBufferInput(bufferId, "")
    runAction("enter-insert-mode")
}

fn infoModalClose() {
    infoModal["active"] = false
    infoModal["scroll"] = 0
    let previousBufferId = infoModal["previous_buffer_id"]
    if previousBufferId != -1 {
        setActiveBuffer(previousBufferId)
    }
    runAction("quit-insert-mode")
}

fn infoModalScrollUp() {
    if !infoModal["active"] { return null }
    let infoModalScroll = infoModal["scroll"] - 1
    infoModal["scroll"] = infoModalScroll
    infoModalRender()
}

fn infoModalScrollDown() {
    if !infoModal["active"] { return null }
    let infoModalScroll = infoModal["scroll"] + 1
    infoModal["scroll"] = infoModalScroll
    infoModalRender()
}

fn infoModalPageUp() {
    if !infoModal["active"] { return null }
    let infoModalScroll = infoModal["scroll"] - infoModal["page_size"]
    infoModal["scroll"] = infoModalScroll
    infoModalRender()
}

fn infoModalPageDown() {
    if !infoModal["active"] { return null }
    let infoModalScroll = infoModal["scroll"] + infoModal["page_size"]
    infoModal["scroll"] = infoModalScroll
    infoModalRender()
}

##############

fn rerenderAllUi() {
    renderDashboard()

    if llmChat["id"] != -1 { renderLLMChat() }
    if fuzzyFileFinder["id"] != -1 { renderFuzzyFileFinder() }
    if switchBuffer["id"] != -1 { renderSwitchBuffer() }
    if workspaceSearch["id"] != -1 { renderWorkspaceSearch() }
    if workspaceDiagnostics["id"] != -1 { renderWorkspaceDiagnostics() }
    if commandDispatcher["id"] != -1 { renderCommandDispatcher() }
    if goToDefinition["id"] != -1 { renderGoToDefinition() }
    if goToReferences["id"] != -1 { renderGoToReferences() }
    if dialogModal["active"] { dialogModalRender() }
    if infoModal["active"] { infoModalRender() }
}

createDashboardBuffer()
refreshViewportSize()
runAction("set-init-rsl-complete")
